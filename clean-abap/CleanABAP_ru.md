> Переведено с [оригинала на английском от 18.03.2022](https://github.com/SAP/styleguides/tree/67dbe274548b8843d3807f0cc98b4655aa2c441b).
> Последняя версия [на английском](CleanABAP.md).

# Чистый ABAP

> [**Русский**](CleanABAP_ru.md)
> &nbsp;·&nbsp;
> [English](CleanABAP.md)
> &nbsp;·&nbsp;
> [中文](CleanABAP_zh.md)
> &nbsp;·&nbsp;
> [Français](CleanABAP_fr.md)
> &nbsp;·&nbsp;
> [Deutsch](CleanABAP_de.md)
> &nbsp;·&nbsp;
> [日本語](CleanABAP_ja.md)
> &nbsp;·&nbsp;
> [Español](CleanABAP_es.md)
> &nbsp;·&nbsp;
> [한국어](CleanABAP_kr.md)

Это руководство является адаптацией книги 
[Robert C. Martin's _Clean Code_]
для [ABAP](https://en.wikipedia.org/wiki/ABAP).

[Шпаргалка](cheat-sheet/CheatSheet.md) - это версия, оптимизированная для печати.

[Robert C. Martin's _Clean Code_]: https://www.oreilly.com/library/view/clean-code/9780136083238/

## Содержание

- [Инструкция](#инструкция)
  - [Как начать работу с Чистым кодом](#как-начать-работу-с-чистым-кодом)
  - [Как рефакторить устаревший код](#как-рефакторить-устаревший-код)
  - [Как выполнять автоматическую проверку](#как-выполнять-автоматическую-проверку)
  - [Как относиться к другим руководствам](#как-относиться-к-другим-руководствам)
  - [Как выражать несогласие](#как-выражать-несогласие)
- [Имена](#имена)
  - [Используйте описательные имена](#используйте-описательные-имена)
  - [Предпочитайте термины из предметной области решения и предметной области проблемы](#предпочитайте-термины-из-предметной-области-решения-и-предметной-области-проблемы)
  - [Используйте множественной число](#используйте-множественное-число)
  - [Используйте произносимые имена](#используйте-произносимые-имена)
  - [Избегайте сокращений](#избегайте-сокращений)
  - [Используйте одни и те же сокращения везде](#используйте-одни-и-те-же-сокращения-везде)
  - [Используйте существительные для классов и глаголы для методов](#используйте-существительные-для-классов-и-глаголы-для-методов)
  - [Избегайте неинформативных слов, таких как "data", "info", "object"](#избегайте-неинформативных-слов-таких-как-data-info-object)
  - [Выберите одно слово для каждой концепции](#выберите-одно-слово-для-каждой-концепции)
  - [Используйте имена шаблонов, только если вы имеете в виду именно их](#используйте-имена-шаблонов-только-если-вы-имеете-в-виду-именно-их)
  - [Избегайте схем кодирования имен, особенно венгерскую нотацию и префиксы](#избегайте-схем-кодирования-имен-особенно-венгерскую-нотацию-и-префиксы)
  - [Избегайте перекрытия встроенных функций](#избегайте-перекрытия-встроенных-функций)
- [Язык](#язык)
  - [Помните о наследии](#помните-о-наследии)
  - [Помните о производительности](#помните-о-производительности)
  - [Предпочитайте объектно-ориентированное программирование процедурному](#предпочитайте-объектно-ориентированное-программирование-процедурному)
  - [Предпочитайте функциональные языковые конструкции процедурным](#предпочитайте-функциональные-языковые-конструкции-процедурным)
  - [Избегайте устаревших языковых элементов](#избегайте-устаревших-языковых-элементов)
  - [Используйте шаблоны проектирования с умом](#используйте-шаблоны-проектирования-с-умом)
- [Константы](#константы)
  - [Используйте константы вместо магических чисел](#используйте-константы-вместо-магических-чисел)
  - [Предпочитайте классы перечисления интерфейсам констант](#предпочитайте-классы-перечисления-интерфейсам-констант)
  - [Если вы не используете классы перечисления, сгруппируйте свои константы](#если-вы-не-используете-классы-перечисления-сгруппируйте-свои-константы)
- [Переменные](#переменные)
  - [Предпочитайте встроенные объявления предварительным](#предпочитайте-встроенные-объявления-предварительным)
  - [Не используйте встроенные объявления в необязательных ветвях](#не-используйте-встроенные-объявления-в-необязательных-ветвях)
  - [Не сцепливайте предварительные объявления](#не-сцепливайте-предварительные-объявления)
  - [Предпочитайте REF TO вместо FIELD-SYMBOL](#предпочитайте-ref-to-вместо-field-symbol)
- [Таблицы](#таблицы)
  - [Используйте правильный тип таблицы](#используйте-правильный-тип-таблицы)
  - [Избегайте DEFAULT KEY](#избегайте-default-key)
  - [Предпочитайте INSERT INTO TABLE вместо APPEND TO](#предпочитайте-insert-into-table-вместо-append-to)
  - [Предпочитайте LINE_EXISTS вместо READ TABLE или LOOP AT](#предпочитайте-line_exists-вместо-read-table-или-loop-at)
  - [Предпочитайте READ TABLE вместо LOOP AT](#предпочитайте-read-table-вместо-loop-at)
  - [Предпочитайте LOOP AT WHERE вместо вложенных IF](#предпочитайте-loop-at-where-вместо-вложенных-if)
  - [Избегайте ненужного чтения таблиц](#избегайте-ненужного-чтения-таблиц)
- [Строки](#строки)
  - [Используйте ` чтобы определить литералы](#используйте--чтобы-определить-литералы)
  - [Используйте | чтобы собрать текст](#используйте--чтобы-собрать-текст)
- [Булевы значения](#булевы-значения)
  - [Используйте булевы значения с умом](#используйте-булевы-значения-с-умом)
  - [Используйте ABAP_BOOL для булевых значений](#используйте-abap_bool-для-булевых-значений)
  - [Используйте ABAP_TRUE и ABAP_FALSE для сравнения](#используйте-abap_true-и-abap_false-для-сравнения)
  - [Используйте XSDBOOL чтобы установить логические переменные](#используйте-xsdbool-чтобы-установить-логические-переменные)
- [Условия](#условия)
  - [Постарайтесь сделать условия положительными](#постарайтесь-сделать-условия-положительными)
  - [Предпочитайте IS NOT вместо NOT IS](#предпочитайте-is-not-вместо-not-is)
  - [Подумайте об использовании предикативных вызовов для булевых методов](#подумайте-об-использовании-предикативных-вызовов-для-булевых-методов)
  - [Подумайте о декомпозиции сложных условий](#подумайте-о-декомпозиции-сложных-условий)
  - [Подумайте об извлечении сложных условий](#подумайте-об-извлечении-сложных-условий)
- [Если](#если)
  - [Не допускайте пустых ветвей IF](#не-допускайте-пустых-ветвей-if)
  - [Предпочитайте CASE вместо ELSE IF для нескольких альтернативных условий](#предпочитайте-case-вместо-else-if-для-нескольких-альтернативных-условий)
  - [Сохраняйте глубину вложенности низкой](#сохраняйте-глубину-вложенности-низкой)
- [Регулярные выражения](#регулярные-выражения)
  - [Предпочитайте более простые методы регулярным выражениям](#предпочитайте-более-простые-методы-регулярным-выражениям)
  - [Предпочитайте базовые проверки регулярным выражениям](#предпочитайте-базовые-проверки-регулярным-выражениям)
  - [Рассмотрите возможность сборки сложных регулярных выражений](#рассмотрите-возможность-сборки-сложных-регулярных-выражений)
- [Классы](#классы)
  - [Классы: Объектная ориентация](#классы-объектная-ориентация)
    - [Предпочитайте объекты статическим классам](#предпочитайте-объекты-статическим-классам)
    - [Предпочитайте композицию наследованию](#предпочитайте-композицию-наследованию)
    - [Не смешивайте парадигмы с сохранением состояния и без сохранения состояния в одном классе](#не-смешивайте-парадигмы-с-сохранением-состояния-и-без-сохранения-состояния-в-одном-классе)
  - [Область видимости](#область-видимости)
    - [Глобальный по умолчанию, локальный только при необходимости](#глобальный-по-умолчанию-локальный-только-при-необходимости)
    - [FINAL если не предназначен для наследования](#final-если-не-предназначен-для-наследования)
    - [PRIVATE по умолчанию, PROTECTED только если нужно](#private-по-умолчанию-protected-только-если-нужно)
    - [Рассмотрите возможность использования неизменяемого объекта, вместо добавления геттера](#рассмотрите-возможность-использования-неизменяемого-объекта-вместо-добавления-геттера)
    - [Используйте READ-ONLY с осторожностью](#используйте-read-only-с-осторожностью)
  - [Конструкторы](#конструкторы)
    - [Предпочитайте NEW вместо CREATE OBJECT](#предпочитайте-new-вместо-create-object)
    - [Если ваш глобальный класс CREATE PRIVATE, сделайте его CONSTRUCTOR публичным](#если-ваш-глобальный-класс-create-private-сделайте-его-constructor-публичным)
    - [Предпочитайте несколько статических методов созданию необязательных параметров](#предпочитайте-несколько-статических-методов-созданию-необязательных-параметров)
    - [Используйте описательные имена для нескольких методов создания](#используйте-описательные-имена-для-нескольких-методов-создания)
    - [Создавайте синглтоны только там, где несколько экземпляров не имеют смысла](#создавайте-синглтоны-только-там-где-несколько-экземпляров-не-имеют-смысла)
- [Методы](#методы)
  - [Вызовы](#вызовы)
    - [Не вызывайте статические методы через переменные экземпляра](#не-вызывайте-статические-методы-через-переменные-экземпляра)
    - [Предпочитайте функциональные вызовы процедурным](#предпочитайте-функциональные-вызовы-процедурным)
    - [Не указывайте RECEIVING](#не-указывайте-receiving)
    - [Не указывайте необязательное ключевое слово EXPORTING](#не-указывайте-необязательное-ключевое-слово-exporting)
    - [Не указывайте имя параметра при вызовах с одним параметром](#не-указывайте-имя-параметра-при-вызовах-с-одним-параметром)
    - [Не указывайте ссылку на себя me при вызове атрибута или метода экземпляра](#не-указывайте-ссылку-на-себя-me-при-вызове-атрибута-или-метода-экземпляра)
  - [Методы: Объектная ориентация](#методы-объектная-ориентация)
    - [Предпочитайте экземпляр статическим методам](#предпочитайте-экземпляр-статическим-методам)
    - [Публичные методы экземпляра должны быть частью интерфейса](#публичные-методы-экземпляра-должны-быть-частью-интерфейса)
  - [Количество параметров](#количество-параметров)
    - [Стремитесь к нескольким IMPORTING параметрам, лучше всего меньше трех](#стремитесь-к-нескольким-importing-параметрам-лучше-всего-меньше-трех)
    - [Разделите методы вместо добавления OPTIONAL параметров](#разделите-методы-вместо-добавления-optional-параметров)
    - [Используйте PREFERRED PARAMETER с осторожностью](#используйте-preferred-parameter-с-осторожностью)
    - [RETURN, EXPORT, или CHANGE только одного параметра](#return-export-или-change-только-одного-параметра)
  - [Типы параметров](#типы-параметров)
    - [Предпочитайте RETURNING вместо EXPORTING](#предпочитайте-returning-вместо-exporting)
    - [RETURNING больших таблиц это обычно нормально](#returning-больших-таблиц-это-обычно-нормально)
    - [Используйте либо RETURNING, либо EXPORTING, либо CHANGING, но не комбинацию](#используйте-либо-returning-либо-exporting-либо-changing-но-не-комбинацию)
    - [Используйте CHANGING с осторожностью, там, где это подходит](#используйте-changing-с-осторожностью-там-где-это-подходит)
    - [Разделите метод вместо использования булева входного параметра](#разделите-метод-вместо-использования-булева-входного-параметра)
  - [Имена параметров](#имена-параметров)
    - [Подумайте о том, чтобы назвать RETURNING параметр RESULT](#подумайте-о-том-чтобы-назвать-returning-параметр-result)
  - [Инициализация параметров](#инициализация-параметров)
    - [Очистите или перезапишите EXPORTING ссылочные параметры](#очистите-или-перезапишите-exporting-ссылочные-параметры)
      - [Будьте осторожны с идентичным вводом и выводом](#будьте-осторожны-с-идентичным-вводом-и-выводом)
    - [Не очищайте VALUE параметры](#не-очищайте-value-параметры)
  - [Тело метода](#тело-метода)
    - [Делай что-то одно, делай это хорошо, делай только это](#делай-что-то-одно-делай-это-хорошо-делай-только-это)
    - [Сосредоточьтесь либо на благополучном исходе либо на обработке ошибок, но не на том и другом одновременно](#сосредоточьтесь-либо-на-благополучном-исходе-либо-на-обработке-ошибок-но-не-на-том-и-другом-одновременно)
    - [Спуститесь на один уровень абстракции](#спуститесь-на-один-уровень-абстракции)
    - [Сохраняйте методы небольшими](#сохраняйте-методы-небольшими)
  - [Поток управления](#поток-управления)
    - [Быстрый провал](#быстрый-провал)
    - [CHECK против RETURN](#check-против-return)
    - [Избегайте CHECK в других местах](#избегайте-check-в-других-местах)
- [Обработка ошибок](#обработка-ошибок)
  - [Сообщения](#сообщения)
    - [Сделайте сообщения легко находимыми](#сделайте-сообщения-легко-находимыми)
  - [Коды возврата](#коды-возврата)
    - [Предпочитайте исключения кодам возврата](#предпочитайте-исключения-кодам-возврата)
    - [Не позволяйте неудачам проскользнуть](#не-позволяйте-неудачам-проскользнуть)
  - [Исключения](#исключения)
    - [Исключения для ошибок, а не для обычных случаев](#исключения-для-ошибок-а-не-для-обычных-случаев)
    - [Используйте исключения на основе классов](#используйте-исключения-на-основе-классов)
  - [Бросание](#бросание)
    - [Используйте собственные суперклассы](#используйте-собственные-суперклассы)
    - [Бросайте один тип исключения](#бросайте-один-тип-исключения)
    - [Используйте подклассы, чтобы вызывающие могли различать ошибочные ситуации](#используйте-подклассы-чтобы-вызывающие-могли-различать-ошибочные-ситуации)
    - [Бросайте CX_STATIC_CHECK для управляемых исключений](#бросайте-cx_static_check-для-управляемых-исключений)
    - [Бросайте CX_NO_CHECK для обычно безнадежных ситуаций](#бросайте-cx_no_check-для-обычно-безнадежных-ситуаций)
    - [Подумайте об использовании CX_DYNAMIC_CHECK для исключений, которых можно избежать](#подумайте-об-использовании-cx_dynamic_check-для-исключений-которых-можно-избежать)
    - [Дамп для полностью неисправимых ситуаций](#дамп-для-полностью-неисправимых-ситуаций)
    - [Предпочитайте RAISE EXCEPTION NEW вместо RAISE EXCEPTION TYPE](#предпочитайте-raise-exception-new-вместо-raise-exception-type)
  - [Отлавливание](#отлавливание)
    - [Оберните внешние исключения вместо того, чтобы позволять им вторгаться в ваш код](#оберните-внешние-исключения-вместо-того-чтобы-позволять-им-вторгаться-в-ваш-код)
- [Комментарии](#комментарии)
  - [Выражайте себя в коде, а не в комментариях](#выражайте-себя-в-коде-а-не-в-комментариях)
  - [Комментарии — не оправдание плохих имен](#комментарии--не-оправдание-плохих-имен)
  - [Используйте методы вместо комментариев для сегментации кода](#используйте-методы-вместо-комментариев-для-сегментации-кода)
  - [Пишите комментарии, чтобы объяснить, почему, а не что](#пишите-комментарии-чтобы-объяснить-почему-а-не-что)
  - [Описание проекта должно быть в проектной документации, а не в коде](#описание-проекта-должно-быть-в-проектной-документации-а-не-в-коде)
  - [Комментируйте используя ", а не *](#комментируйте-используя--а-не-)
  - [Размещайте комментарии перед утверждением, к которому они относятся](#размещайте-комментарии-перед-утверждением-к-которому-они-относятся)
  - [Удаляйте код вместо того, чтобы комментировать его](#удаляйте-код-вместо-того-чтобы-комментировать-его)
  - [Используйте FIXME, TODO, и XXX и добавьте свой ID](#используйте-fixme-todo-и-xxx-и-добавьте-свой-id)
  - [Не добавляйте сигнатуру метода и комментарии в конце](#не-добавляйте-сигнатуру-метода-и-комментарии-в-конце)
  - [Не дублируйте тексты сообщений в комментариях](#не-дублируйте-тексты-сообщений-в-комментариях)
  - [ABAP Doc только для публичных APIs](#abap-doc-только-для-публичных-apis)
  - [Предпочитайте прагмы псевдокомментариям](#предпочитайте-прагмы-псевдокомментариям)
- [Форматирование](#форматирование)
  - [Будьте последовательны](#будьте-последовательны)
  - [Оптимизируйте код для чтения, а не для написания](#оптимизируйте-код-для-чтения-а-не-для-написания)
  - [Используйте структурную печать перед активацией](#используйте-структурную-печать-перед-активацией)
  - [Используйте настройки структурной печати вашей команды](#используйте-настройки-структурной-печати-вашей-команды)
  - [Не более одного оператора в строке](#не-более-одного-оператора-в-строке)
  - [Придерживайтесь разумной длины строки](#придерживайтесь-разумной-длины-строки)
  - [Уплотните ваш код](#уплотните-ваш-код)
  - [Добавьте только одну пустую строку для разделения разных вещей, не более](#добавьте-только-одну-пустую-строку-для-разделения-разных-вещей-не-более)
  - [Не злоупотребляйте разделением пустыми строками](#не-злоупотребляйте-разделением-пустыми-строками)
  - [Выравнивайте присвоения для одного и того же объекта, но не для разных](#выравнивайте-присвоения-для-одного-и-того-же-объекта-но-не-для-разных)
  - [Закрывайте скобки в конце строки](#закрывайте-скобки-в-конце-строки)
  - [При вызове с одним параметром указывайте его на той же строке](#при-вызове-с-одним-параметром-указывайте-его-на-той-же-строке)
  - [Указывайте параметры начиная со строки вызова](#указывайте-параметры-начиная-со-строки-вызова)
  - [При переносе строки сделайте отступ для параметров под вызовом](#при-переносе-строки-сделайте-отступ-для-параметров-под-вызовом)
  - [Сделайте разрыв строки для нескольких параметров](#сделайте-разрыв-строки-для-нескольких-параметров)
  - [Выровняйте параметры](#выровняйте-параметры)
  - [Перенесите вызов на новую строку, если она станет слишком длинной](#перенесите-вызов-на-новую-строку-если-она-станет-слишком-длинной)
  - [Добавьте отступы и табуляцию](#добавьте-отступы-и-табуляцию)
  - [Сделайте отступ для встроенных объявлений, таких как вызовы методов](#сделайте-отступ-для-встроенных-объявлений-таких-как-вызовы-методов)
  - [Не выравнивайте указания типов](#не-выравнивайте-указания-типов)
  - [Не объединяйте присвоения](#не-объединяйте-присвоения)
- [Тестирование](#тестирование)
  - [Принципы](#принципы)
    - [Пишите тестируемый код](#пишите-тестируемый-код)
    - [Позвольте другим создавать моки](#позвольте-другим-создавать-моки)
    - [Правила удобочитаемости](#правила-удобочитаемости)
    - [Не делайте копии и не пишите тестовые отчеты](#не-делайте-копии-и-не-пишите-тестовые-отчеты)
    - [Тестируйте публичные, а не приватные части](#тестируйте-публичные-а-не-приватные-части)
    - [Не зацикливайтесь на покрытии кода](#не-зацикливайтесь-на-покрытии-кода)
  - [Тестовые классы](#тестовые-классы)
    - [Называйте локальные тестовые классы в соответствии с их назначением](#называйте-локальные-тестовые-классы-в-соответствии-с-их-назначением)
    - [Поместите тесты в локальные классы](#поместите-тесты-в-локальные-классы)
    - [Поместите вспомогательные методы во вспомогательные классы](#поместите-вспомогательные-методы-во-вспомогательные-классы)
    - [Как выполнять тестовые классы](#как-выполнять-тестовые-классы)
  - [Тестируемый код](#тестируемый-код)
    - [Дайте осмысленное имя тестируемому коду или используйте имя по умолчанию CUT](#дайте-осмысленное-имя-тестируемому-коду-или-используйте-имя-по-умолчанию-cut)
    - [Тестируйте интерфейсы, а не реализации](#тестируйте-интерфейсы-а-не-реализации)
    - [Поместите вызов тестируемого кода в отдельный метод](#поместите-вызов-тестируемого-кода-в-отдельный-метод)
  - [Инъекция](#инъекция)
    - [Используйте инверсию зависимостей для внедрения тестовых двойников](#используйте-инверсию-зависимостей-для-внедрения-тестовых-двойников)
    - [Рассмотрите возможность использования инструмента ABAP test double](#рассмотрите-возможность-использования-инструмента-abap-test-double)
    - [Используйте инструменты тестирования](#используйте-инструменты-тестирования)
    - [Используйте тестовые швы как временное решение](#используйте-тестовые-швы-как-временное-решение)
    - [Используйте LOCAL FRIENDS для доступа к конструктору инверсии зависимостей](#используйте-local-friends-для-доступа-к-конструктору-инверсии-зависимостей)
    - [Не злоупотребляйте LOCAL FRIENDS для вторжения в проверенный код](#не-злоупотребляйте-local-friends-для-вторжения-в-проверенный-код)
    - [Не изменяйте продуктивный код, чтобы сделать код пригодным для тестирования](#не-изменяйте-продуктивный-код-чтобы-сделать-код-пригодным-для-тестирования)
    - [Не создавайте подклассы чтобы замокать методы](#не-создавайте-подклассы-чтобы-замокать-методы)
    - [Не мокайте то, что вам не нужно](#не-мокайте-то-что-вам-не-нужно)
    - [Не создавайте тестовые фреймворки](#не-создавайте-тестовые-фреймворки)
  - [Тестовые методы](#тестовые-методы)
    - [Названия тестовых методов должны отражать то, что дано и что ожидается](#названия-тестовых-методов-должны-отражать-то-что-дано-и-что-ожидается)
    - [Используйте формат дано-когда-тогда](#используйте-формат-дано-когда-тогда)
    - ["Когда" ровно один вызов](#когда-ровно-один-вызов)
    - [Не добавляйте TEARDOWN если вам это не нужно](#не-добавляйте-teardown-если-вам-это-не-нужно)
  - [Тестовые данные](#тестовые-данные)
    - [Упростите определение смысла](#упростите-определение-смысла)
    - [Упростите поиск различий](#упростите-поиск-различий)
    - [Используйте константы для описания предназначения тестовых данных](#используйте-константы-для-описания-предназначения-тестовых-данных)
  - [Утверждения](#утверждения)
    - [Несколько целенаправленных утверждений](#несколько-целенаправленных-утверждений)
    - [Используйте правильный тип утверждения](#используйте-правильный-тип-утверждения)
    - [Утверждайте содержание, а не количество](#утверждайте-содержание-а-не-количество)
    - [Утверждайте качество, а не содержание](#утверждайте-качество-а-не-содержание)
    - [Используйте FAIL для проверки ожидаемых исключений](#используйте-fail-для-проверки-ожидаемых-исключений)
    - [Не перехватывайте неожиданные исключения, а перенаправляйте их](#не-перехватывайте-неожиданные-исключения-а-перенаправляйте-их)
    - [Напишите собственные утверждения чтобы сократить код и избежать дублирования](#напишите-собственные-утверждения-чтобы-сократить-код-и-избежать-дублирования)

## Инструкция

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Эта секция](#инструкция)

### Как начать работу с Чистым кодом

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Инструкция](#инструкция) > [Эта секция](#как-начать-работу-с-чистым-кодом)

Если Чистый код для вас что-то новое, вам следует сначала прочитать книгу
[Robert C. Martin's _Clean Code_].
Начать с плавного пошагового погружения в тему в целом вам может помочь книга [Clean Code Developer initiative](https://clean-code-developer.com/).

Мы рекомендуем вам начать с простых для понимания и общепринятых вещей,
например: [Булевы значения](#булевы-значения), [Условия](#условия), and [Если](#если).

Скорее всего, наиболее полезными для вас разделами будут [Методы](#методы),
особенно [Делай что-то одно, делай это хорошо, делай только это](#делай-что-то-одно-делай-это-хорошо-делай-только-это) и [Сохраняйте методы небольшими](#сохраняйте-методы-небольшими), потому что они значительно улучшают общую структуру вашего кода.

Некоторые рекомендации описанные здесь могут вызвать сложные дискуссии в командах, 
которые опытны в своем деле, но новички в чистом коде; 
не смотря на то, что эти рекомендации совершенно "здравые", поначалу с ними у людей могут возникать проблемы.

Вернемся к таким спорным рекомендациям позже; 
такие разделы как [Комментарии](#комментарии), [Имена](#имена) и [Форматирование](#форматирование)
могут привести к почти религиозным спорам
которые должны учитываться только командами, которые уже видели доказательства положительных эффектов Чистого кода.

### Как рефакторить устаревший код

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Инструкция](#инструкция) > [Эта секция](#как-рефакторить-устаревший-код)

Разделы [Булевы значения](#булевы-значения), [Условия](#условия), [Если](#если)
и [Методы](#методы) будут вам наиболее полезны, если вы работаете над устаревшим проектом
с большим количеством кода, который вы не можете или не хотите изменять.
Описанные в этом разделе рекомендации могут быть применены к новому коду без каких-либо конфликтов.

Тема [Имена](#имена) очень требовательна к устаревшим проектам,
поскольку может привести к разрыву между старым и новым кодом,
вплоть до того, что, к примеру, раздел
[Избегайте схем кодирования имен, особенно венгерскую нотацию и префиксы](#избегайте-схем-кодирования-имен-особенно-венгерскую-нотацию-и-префиксы)
лучше вообще игнорировать.

При выполнении рефакторинга старайтесь не смешивать разные стили разработки 
в одном и том же объекте разработки. Если устаревший код содержит 
только предварительные объявления, а полный рефакторинг с использованием 
встроенных (inline) объявлений невозможен, вероятно, лучше придерживаться устаревшего стиля, 
а не смешивать их. Существует несколько подобных ситуаций, 
когда смешивание стилей может привести к путанице, например:

- Смешивание `REF TO` и `FIELD-SYMBOL` при выполнении цикла.
- Смешивание `NEW` и `CREATE OBJECT` при вызове `CONSTRUCTOR`.
- Смешивание `RETURNING` и `EXPORTING` в сигнатуре методов возвращающих/экспортирующих только один параметр.

Мы получили хорошие результаты используя четырехэтапный план рефакторинга:

1. Соберите команду. Сообщите и объясните им новый стиль написания кода.
Убедите всю команду проекта согласиться с ним.
Вам не нужно закреплять все рекомендации сразу, просто начните
с небольших очевидных вещей.

2. Следуйте _правилу бойскаута_ в своей повседневной работе:
_всегда оставляйте код, который вы редактируете, немного чище того, каким он был раньше_.
Не зацикливайтесь на этом, тратя часы на «уборку лагеря».
Просто потратьте пару дополнительных минут и посмотрите, как
со временем код будет улучшаться.

3. Создайте _чистые острова_: время от времени выбирайте небольшой объект или компонент и
старайтесь сделать его чистым во всех отношениях. Эти острова будут демонстрировать преимущества
того, что вы делаете, и сформируют надежную проверенную базу для дальнейшего рефакторинга.

4. Обсуждайте это. Независимо от того, проводите ли вы старомодную инспекцию кода [инспекция Фогана](https://en.wikipedia.org/wiki/Fagan_inspection ),
проводите информационные сессии или создаёте доски обсуждений в своем любимом чате:
вам нужно будет рассказыть о своем опыте и знаниях, чтобы
команда могла прийти у общему пониманию.

### Как выполнять автоматическую проверку

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Инструкция](#инструкция) > [Эта секция](#как-выполнять-автоматическую-проверку)

[code pal for ABAP](https://github.com/SAP/code-pal-for-abap)
предоставляет полный набор автоматических проверок для Чистого ABAP.

ABAP Test Cockpit, Code Inspector, Расширенная проверка программы, и Checkman предоставляют
некоторые проверки, которые могут помочь вам обнаружить определенные проблемы.

[abapOpenChecks](https://github.com/larshp/abapOpenChecks),
коллекция проверок с открытым исходным кодом для Code Inspector,
также охватывает некоторые из описанных антипаттернов.

[abaplint](https://github.com/abaplint/abaplint) это повторная реализация ABAP-парсера с открытым исходным кодом. Он работает без системы SAP и предназначен для использования в коде, сериализованном с помощью abapGit. Инструмент предлагает множество интеграций (GitHub Actions, Jenkins, текстовые редакторы...), проверяет отсутствие в коде некоторых антипаттернов, а также может использоваться для проверки соглашений о форматировании и коде.

### Как относиться к другим руководствам

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Инструкция](#инструкция) > [Эта секция](#как-относиться-к-другим-руководствам)

Наше руководство следует _духу_ Чистого кода,
что означает, что мы адаптировали некоторые вещи к языку программирования ABAP, 
например [Бросайте CX_STATIC_CHECK для управляемых исключений](#бросайте-cx_static_check-для-управляемых-исключений).

Некоторые факты взяты из 
[Руководство по программированию на ABAP](https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-US/index.htm?file=abenabap_pgl.htm),
с которым это руководство в основном совместимо; отклонения указаны и всегда соответствуют духу более чистого кода.

Это руководство также учитывает
[Рекомендации DSAG по ABAP разработке](https://www.dsag.de/sites/default/files/2020-12/dsag_recommendation_abap_development.pdf),
хотя мы более точны в большинстве деталей.

С момента публикации Clean ABAP стал справочным руководством
для многих внутренних команд разработчиков SAP,
включая несколько сотен кодеров, работающих над S/4HANA.

### Как выражать несогласие

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Инструкция](#инструкция) > [Эта секция](#как-выражать-несогласие)

Мы написали это руководство по стилю программирования для читателей, которые уже знакомы с Чистым кодом или которые прямо сейчас знакомятся с ним,
уделяя особое внимание тому, как применять его _конкретно к ABAP_.

Пожалуйста, имейте в виду, что именно поэтому мы не описали все концепции одинаково подробно и глубоко 
как в оригинальной книге и связанных с ней ресурсах: их все равно стоит прочитать,
особенно если вы не согласны с вещами описанными здесь только потому, что мы не очень хорошо их объяснили.
Используйте ссылки в разделах, чтобы ознакомиться с предпосылками нашего руководства.

Вы можете свободно обсуждать и не соглашаться с чем-либо, о чем мы здесь говорим.
Одним из столпов Чистого кода является то, что называется _правила команды_.
Просто постарайтесь дать чему-либо шанс, прежде чем отбросить это.

[CONTRIBUTING.md](../CONTRIBUTING.md) предлагает способы того, как вы можете изменить это руководство или отклониться от него в незначительных деталях.

## Имена

[Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Эта секция](#имена)

### Используйте описательные имена

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Имена](#имена) > [Эта секция](#используйте-описательные-имена)

Используйте имена, которые передают содержание и смысл вещей.

```ABAP
CONSTANTS max_wait_time_in_seconds TYPE i ...
DATA customizing_entries TYPE STANDARD TABLE ...
METHODS read_user_preferences ...
CLASS /clean/user_preference_reader ...
```

Не акцентируйте внимание на типе данных или технической кодировке.
Они вряд ли способствуют пониманию кода.

```ABAP
" anti-pattern
CONSTANTS sysubrc_04 TYPE sysubrc ...
DATA iso3166tab TYPE STANDARD TABLE ...
METHODS read_t005 ...
CLASS /dirty/t005_reader ...
```

[Не пытайтесь исправить плохие имена с помощью комментариев.](#комментарии--не-оправдание-плохих-имен)

> Подробнее в _Chapter 2: Meaningful Names: Use Intention-Revealing Names_ [Robert C. Martin's _Clean Code_].

### Предпочитайте термины из предметной области решения и предметной области проблемы

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Имена](#имена) > [Эта секция](#предпочитайте-термины-из-предметной-области-решения-и-предметной-области-проблемы)

Ищите подходящие имена из области решения, т.е. термины информатики, такие как "очередь" или "дерево",
и в проблемной области, т.е. термины бизнес-сферы, такие как "учетная запись" или "бухгалтерская книга".

Слои, обеспечивающие бизнес-функциональность лучше всего называть в соответствии с проблемной областью.
Особенно это относится к компонентам, разработанным с помощью предметно-ориентированного проектирования, например API и бизнес-объекты.

Слои, обеспечивающие в основном техническую функциональность, такие как фабричные классы и абстрактные алгоритмы,
лучше называть в соответствии с областью решения.

В любом случае, не пытайтесь придумать свой собственный язык.
Нам нужно иметь возможность обмениваться информацией между разработчиками, владельцами продуктов, партнерами и клиентами,
поэтому выбирайте имена, которые будут понятны всем им без специального словаря.

> Подробнее в _Chapter 2: Meaningful Names: Use Solution Domain Names_ and _[...]:
> Use Problem Domain Names_ [Robert C. Martin's _Clean Code_].

### Используйте множественное число

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Имена](#имена) > [Эта секция](#используйте-множественное-число)

В SAP существует унаследованная практика называть таблицы объектов в единственном числе,
например `country` (страна) для "таблицы стран".
Распространенной тенденцией во внешнем мире является использование множественного числа для списков вещей.
Поэтому мы рекомендуем вместо этого использовать `countries` (страны).

> Этот совет в первую очередь относится к переменным и свойствам.
> Для объектов разработки могут быть уместны другие шаблоны,
> например, широко используемое соглашение
> называть таблицы базы данных ("прозрачные таблицы") в единственном числе.

> Подробнее в _Chapter 2: Meaningful Names: Use Intention-Revealing Names_ [Robert C. Martin's _Clean Code_].

### Используйте произносимые имена

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Имена](#имена) > [Эта секция](#используйте-произносимые-имена)

Мы много думаем и говорим об объектах. Поэтому используйте имена, которые каждый может произнести. 
Например, используйте discovery_object_types, а не что-то загадочное вроде dobjt.

> Подробнее в _Chapter 2: Meaningful Names: Use Pronounceable Names_ [Robert C. Martin's _Clean Code_]

### Избегайте сокращений

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Имена](#имена) > [Эта секция](#избегайте-сокращений)

Если у вас достаточно места, пишите имена полностью.
Начинайте сокращать только в том случае, когда превысите ограничения по длине.

Если вам действительно нужно что-то сократить, начните с _не важных_ слов.

Сокращение названий вещей на первый взгляд может показаться эффективным, но очень быстро становится двусмысленным.
Например, "cust" в `cust` означает "customizing", "customer", или "custom"?
Все три термина распространены в приложениях SAP.

> Подробнее в _Chapter 2: Meaningful Names: Make Meaningful Distinctions_ [Robert C. Martin's _Clean Code_].

### Используйте одни и те же сокращения везде

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Имена](#имена) > [Эта секция](#используйте-одни-и-те-же-сокращения-везде)

Люди будут искать ключевые слова, чтобы найти соответствующий код.
Упростите им задачу, используя одинаковое сокращение для одного и того же.
Например, всегда сокращайте "detection object type" до "dobjt"
вместо сокращений "dot", "dotype", "detobjtype" и тому подобных.

> Подробнее в _Chapter 2: Meaningful Names: Use Searchable Names_ [Robert C. Martin's _Clean Code_].

### Используйте существительные для классов и глаголы для методов

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Имена](#имена) > [Эта секция](#используйте-существительные-для-классов-и-глаголы-для-методов)

Используйте существительные или словосочетания для обозначения классов, интерфейсов и объектов:

```ABAP
CLASS /clean/account
CLASS /clean/user_preferences
INTERFACE /clean/customizing_reader
```

Используйте глаголы или глагольные словосочетания для именования методов:

```ABAP
METHODS withdraw
METHODS add_message
METHODS read_entries
```

Называйте булевы методы начиная с глаголов `is_` и `has_` чтобы сделать чтение приятным:

```ABAP
IF is_empty( table ).
```

Мы рекомендуем называть функции так же как методы:

```ABAP
FUNCTION /clean/read_alerts
```

### Избегайте неинформативных слов, таких как "data", "info", "object"

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Имена](#имена) > [Эта секция](#избегайте-неинформативных-слов-таких-как-data-info-object)

Опустите неинформативные слова

```ABAP
account  " instead of account_data
alert    " instead of alert_object
```

или замените их чем-то конкретным, что добавит смысла

```ABAP
user_preferences          " instead of user_info
response_time_in_seconds  " instead of response_time_variable
```

> Подробнее в _Chapter 2: Meaningful Names: Make Meaningful Distinctions_ [Robert C. Martin's _Clean Code_]

### Выберите одно слово для каждой концепции

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Имена](#имена) > [Эта секция](#выберите-одно-слово-для-каждой-концепции)

```ABAP
METHODS read_this.
METHODS read_that.
METHODS read_those.
```

Выберите один термин для концепции и придерживайтесь его всюду; не смешивайте с другими синонимами.
Синонимы заставят читателя тратить время на поиск разницы, которой нет.

```ABAP
" anti-pattern
METHODS read_this.
METHODS retrieve_that.
METHODS query_those.
```

> Подробнее в _Chapter 2: Meaningful Names: Pick One Word per Concept_ [Robert C. Martin's _Clean Code_]

### Используйте имена шаблонов, только если вы имеете в виду именно их

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Имена](#имена) > [Эта секция](#используйте-имена-шаблонов-только-если-вы-имеете-в-виду-именно-их)

Не используйте названия шаблонов проектирования программного обеспечения для классов и интерфейсов, если вы действительно не имеете их в виду.
Например, не называйте свой класс `file_factory`, если он действительно не реализует шаблон проектирования Фабрика.
К наиболее распространенным шаблонам относятся:
[singleton](https://en.wikipedia.org/wiki/Singleton_pattern),
[factory](https://en.wikipedia.org/wiki/Factory_method_pattern),
[facade](https://en.wikipedia.org/wiki/Facade_pattern),
[composite](https://en.wikipedia.org/wiki/Composite_pattern),
[decorator](https://en.wikipedia.org/wiki/Decorator_pattern),
[iterator](https://en.wikipedia.org/wiki/Iterator_pattern),
[observer](https://en.wikipedia.org/wiki/Observer_pattern), и
[strategy](https://en.wikipedia.org/wiki/Strategy_pattern).

> Подробнее в _Chapter 2: Meaningful Names: Avoid Disinformation_ [Robert C. Martin's _Clean Code_]

### Избегайте схем кодирования имен, особенно венгерскую нотацию и префиксы

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Имена](#имена) > [Эта секция](#избегайте-схем-кодирования-имен-особенно-венгерскую-нотацию-и-префиксы)

Мы рекомендуем вам избавиться от _всех_ префиксов при написании кода.

```ABAP
METHOD add_two_numbers.
  result = a + b.
ENDMETHOD.
```

вместо излишне длинного

```ABAP
METHOD add_two_numbers.
  rv_result = iv_a + iv_b.
ENDMETHOD.
```

> [Избегайте схем кодирования имен](sub-sections/AvoidEncodings.md)
> подробно описывает рассуждения.

### Избегайте перекрытия встроенных функций

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Имена](#имена) > [Эта секция](#избегайте-перекрытия-встроенных-функций)

Внутри класса встроенная функция всегда перекрыта методами класса, если они имеют одно и то же имя, 
независимо от количества и типа аргументов в функции. 
Также, функция перекрыта независимо от количества и типа параметров метода. 
Встроенными функциями являются, например, `condense( )`, `lines( )`, `line_exists( )`, `strlen( )` и т. д.

```ABAP
"anti-pattern
METHODS lines RETURNING VALUE(result) TYPE i.    
METHODS line_exists RETURNING VALUE(result) TYPE i.  
```

```ABAP
"anti-pattern 
CLASS-METHODS condense RETURNING VALUE(result) TYPE i.   
CLASS-METHODS strlen RETURNING VALUE(result) TYPE i.  
```

> Подробнее в [Built-In Functions - Obscuring with Methods](https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-us/abenbuilt_in_functions_syntax.htm#@@ITOC@@ABENBUILT_IN_FUNCTIONS_SYNTAX_3?file=abenbuilt_in_functions_syntax.htm).


## Язык

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Эта секция](#язык)

### Помните о наследии

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Язык](#язык) > [Эта секция](#mind-the-legacy)

Если вы ведете разработку в системах, поддерживающих только более старые версии ABAP, следуйте советам этого руководства с осторожностью.
Во многих приведенных ниже рекомендациях используются относительно новый синтаксис и конструкции, 
которые могут не поддерживаться в более старых версиях ABAP.
Проверьте рекомендации, которым вы хотите следовать в самой старой версии, которую вы должны поддерживать.
Не следует просто отбрасывать Чистый код в целом -
подавляющее большинство правил (например, присвоение имен, комментирование) будут работать в _any_ версии ABAP.

### Помните о производительности

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Язык](#язык) > [Эта секция](#помните-о-производительности)

Если вы разрабатываете высокопроизводительные компоненты, следуйте советам этого руководства с осторожностью.
Некоторые рекомендации Чистого кода могут привести к замедлению работы (большее количество вызовов методов) или потреблять больше памяти (больше объектов).
ABAP имеет некоторые особенности, которые могут усилить это, например, он сравнивает типы данных при вызове метода,
так что разделение одного большого метода на множество подметодов может сделать код медленнее.

Тем не менее, мы настоятельно рекомендуем не проводить преждевременную оптимизацию, основанную на неясных опасениях.
Подавляющее большинство правил (например, присвоение имен, комментирование) вообще не оказывает негативного влияния.
Старайтесь вести разработку используя чистый, объектно-ориентированный подход.
Если что-то работает слишком медленно, проведите измерение производительности.
Только после этого вы можете принять основанное на фактах решение об отмене выбранных правил.

Некоторые дополнительные соображения частично взяты из главы 2
[Martin Fowler's _Refactoring_](https://martinfowler.com/books/refactoring.html):

В типичном приложении бОльшая часть времени выполнения тратится на очень небольшую часть
кода. Всего 10% кода может составлять 90% времени выполнения. Особенно это относится к
ABAP, где большая часть времени выполнения, скорее всего, приходится на время работы с базой данных.

Таким образом, стремление сделать _весь_ код сверхэффективным - это не лучший способ использования ресурсов. 
Мы не предлагаем игнорировать производительность, но лучше больше сосредоточиться на чистом и хорошо структурированном коде 
во время начальной разработки и использовать ABAP Profiler для определения критических областей для оптимизации.

Стоит добавить, что такой подход положительно скажется на производительности, 
так как усилия по оптимизации будут более целенаправленными. Кроме того, 
станет проще выявлять узкие места в производительности, 
а также легче проводить рефакторинг и корректировку хорошо структурированного кода.

### Предпочитайте объектно-ориентированное программирование процедурному

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Язык](#язык) > [Эта секция](#предпочитайте-объектно-ориентированное-программирование-процедурному)

Поскольку объектно-ориентированные программы (классы, интерфейсы) лучше сегментированы, 
их легче рефакторить и тестировать, чем процедурный код (функции, программы). 
В некоторых ситуациях, однако, вам нужно указать процедурные объекты (функции для RFC, программы для транзакций), 
но эти объекты должны служить не более чем для вызова соответствующего класса, который обеспечивает реальную функциональность:

```ABAP
FUNCTION check_business_partner [...].
  DATA(validator) = NEW /clean/biz_partner_validator( ).
  result = validator->validate( business_partners ).
ENDFUNCTION.
```

> [Группы функций против Классов](sub-sections/FunctionGroupsVsClasses.md)
> подробно описывает различия.

### Предпочитайте функциональные языковые конструкции процедурным

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Язык](#язык) > [Эта секция](#предпочитайте-функциональные-языковые-конструкции-процедурным)

Как правило, они короче и более естественны для современных разработчиков.

```ABAP
DATA(variable) = 'A'.
" MOVE 'A' TO variable.

DATA(uppercase) = to_upper( lowercase ).

index += 1.         " >= NW 7.54
index = index + 1.  " < NW 7.54
" ADD 1 TO index.

DATA(object) = NEW /clean/my_class( ).
" CREATE OBJECT object TYPE /dirty/my_class.

result = VALUE #( FOR row IN input ( row-text ) ).
" LOOP AT input INTO DATA(row).
"  INSERT row-text INTO TABLE result.
" ENDLOOP.

DATA(line) = value_pairs[ name = 'A' ]. " entry must exist
DATA(line) = VALUE #( value_pairs[ name = 'A' ] OPTIONAL ). " entry can be missing
" READ TABLE value_pairs INTO DATA(line) WITH KEY name = 'A'.

DATA(exists) = xsdbool( line_exists( value_pairs[ name = 'A' ] ) ).
IF line_exists( value_pairs[ name = 'A' ] ).
" READ TABLE value_pairs TRANSPORTING NO FIELDS WITH KEY name = 'A'.
" DATA(exists) = xsdbool( sy-subrc = 0 ).
```

Многие из подробно описанных правил, приведенных ниже, являются лишь повторением этого общего совета.

### Избегайте устаревших языковых элементов

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Язык](#язык) > [Эта секция](#избегайте-устаревших-языковых-элементов)

После обновления версии ABAP обязательно проверьте наличие устаревших языковых элементов и воздержитесь от их использования.

Например, «host» переменные, экранированные символом `@` в следующей инструкции, 
немного лучше поясняют, что здесь является переменной программы, и что является столбцом в базе данных.

```ABAP
SELECT *
  FROM spfli
  WHERE carrid = @carrid AND
        connid = @connid
  INTO TABLE @itab.
```

по сравнению с [устаревшей неэкранированной формой](https://help.sap.com/doc/abapdocu_750_index_htm/7.50/en-US/abenopen_sql_hostvar_obsolete.htm)

```ABAP
SELECT *
  FROM spfli
  WHERE carrid = carrid AND
        connid = connid
  INTO TABLE itab.
```

Новые альтарнативный синтаксис, как правило, улучшает читаемость кода
и уменьшают конфликты, возникающие при проектировании 
с использованием современных парадигм программирования,
так что переход на них может автоматически сделать ваш код более чистым.

Несмотря на то, что устаревшие элементы продолжают работать, 
устаревшие элементы могут перестать получать обновления от возможных будущих мер по оптимизации
с точки зрения скорости обработки и потребления памяти.

С помощью современных языковых элементов вы можете легче обучать молодых ABAPеров которые, 
возможно, уже не знакомы с устаревшими конструкциями, потому что их больше не используют при обучении на тренингах SAP.

Документация SAP NetWeaver содержит постоянный раздел, 
в котором перечислены устаревшие языковые элементы, например
[NW 7.50](https://help.sap.com/doc/abapdocu_750_index_htm/7.50/en-US/index.htm?file=abenabap_obsolete.htm),
[NW 7.51](https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-US/index.htm?file=abenabap_obsolete.htm),
[NW 7.52](https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/index.htm?file=abenabap_obsolete.htm),
[NW 7.53](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/index.htm?file=abenabap_obsolete.htm).

### Используйте шаблоны проектирования с умом

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Язык](#язык) > [Эта секция](#используйте-шаблоны-проектирования-с-умом)

Там, где они уместны и приносят заметную пользу.
Не используйте шаблоны проектирования везде только ради своего удовольствия.

## Константы

[Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Эта секция](#константы)

### Используйте константы вместо магических чисел

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Константы](#константы) > [Эта секция](#используйте-константы-вместо-магических-чисел)

```ABAP
IF abap_type = cl_abap_typedescr=>typekind_date.
```

понятнее чем

```ABAP
" anti-pattern
IF abap_type = 'D'.
```

> Подробнее в _Chapter 17: Smells and Heuristics: G25:
> Replace Magic Numbers with Named Constants_ [Robert C. Martin's _Clean Code_].

### Предпочитайте классы перечисления интерфейсам констант

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Константы](#константы) > [Эта секция](#предпочитайте-классы-перечисления-интерфейсам-констант)

```ABAP
CLASS /clean/message_severity DEFINITION PUBLIC ABSTRACT FINAL.
  PUBLIC SECTION.
    CONSTANTS:
      warning TYPE symsgty VALUE 'W',
      error   TYPE symsgty VALUE 'E'.
ENDCLASS.
```

или

```ABAP
CLASS /clean/message_severity DEFINITION PUBLIC CREATE PRIVATE FINAL.
  PUBLIC SECTION.
    CLASS-DATA:
      warning TYPE REF TO /clean/message_severity READ-ONLY,
      error   TYPE REF TO /clean/message_severity READ-ONLY.
  " ...
ENDCLASS.
```

вместо того, чтобы смешивать несвязанные вещи
или вводить людей в заблуждение, подталкивая к выводу
о том, что коллекции констант могут быть "реализованы":

```ABAP
" anti-pattern
INTERFACE /dirty/common_constants.
  CONSTANTS:
    warning      TYPE symsgty VALUE 'W',
    transitional TYPE i       VALUE 1,
    error        TYPE symsgty VALUE 'E',
    persisted    TYPE i       VALUE 2.
ENDINTERFACE.
```

> Раздел [Перечисления](sub-sections/Enumerations.md)
> описывает общие шаблоны перечислений
> и рассказывает об их преимуществах и недостатках.
>
> Подробнее в _Chapter 17: Smells and Heuristics: J3: Constants versus Enums_ [Robert C. Martin's _Clean Code_].

### Если вы не используете классы перечисления, сгруппируйте свои константы

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Константы](#константы) > [Эта секция](#если-вы-не-используете-классы-перечисления-сгруппируйте-свои-константы)

Если вы собираете константы произвольным образом, например, в интерфейсе, сгруппируйте их:

```ABAP
CONSTANTS:
  BEGIN OF message_severity,
    warning TYPE symsgty VALUE 'W',
    error   TYPE symsgty VALUE 'E',
  END OF message_severity,
  BEGIN OF message_lifespan,
    transitional TYPE i VALUE 1,
    persisted    TYPE i VALUE 2,
  END OF message_lifespan.
```

Это делает отношение более ясным, чем:

```ABAP
" Anti-pattern
CONSTANTS:
  warning      TYPE symsgty VALUE 'W',
  transitional TYPE i       VALUE 1,
  error        TYPE symsgty VALUE 'E',
  persisted    TYPE i       VALUE 2,
```

Группа также позволяет вам осуществлять групповой доступ, например, для проверки входных данных:

```ABAP
DO.
  ASSIGN COMPONENT sy-index OF STRUCTURE message_severity TO FIELD-SYMBOL(<constant>).
  IF sy-subrc IS INITIAL.
    IF input = <constant>.
      DATA(is_valid) = abap_true.
      RETURN.
    ENDIF.
  ELSE.
    RETURN.
  ENDIF.
ENDDO.
```

> Подробнее в _Chapter 17: Smells and Heuristics: G27: Structure over Convention_ [Robert C. Martin's _Clean Code_].

## Переменные

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Эта секция](#переменные)

### Предпочитайте встроенные объявления предварительным

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Переменные](#переменные) > [Эта секция](#предпочитайте-встроенные-объявления-предварительным)

Если вы будете следовать этим рекомендациям, ваши методы станут настолько короткими (3-5 утверждений), 
что объявление встроенных переменных будет выглядеть более естественно

```ABAP
METHOD do_something.
  DATA(name) = 'something'.
  DATA(reader) = /clean/reader=>get_instance_for( name ).
  result = reader->read_it( ).
ENDMETHOD.
```

чем объявление переменных с отдельной секцией `DATA` в начале метода

```ABAP
" anti-pattern
METHOD do_something.
  DATA:
    name   TYPE seoclsname,
    reader TYPE REF TO /dirty/reader.
  name = 'something'.
  reader = /dirty/reader=>get_instance_for( name ).
  result = reader->read_it( ).
ENDMETHOD.
```

> Подробнее в _Chapter 5: Formatting: Vertical Distance: Variable Declarations_ [Robert C. Martin's _Clean Code_].

### Не используйте встроенные объявления в необязательных ветвях

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Переменные](#переменные) > [Эта секция](#не-используйте-встроенные-объявления-в-необязательных-ветвях)

```ABAP
" anti-pattern
IF has_entries = abap_true.
  DATA(value) = 1.
ELSE.
  value = 2.
ENDIF.
```

Это прекрасно работает, потому что ABAP обрабатывает встроенные объявления так, как если бы они находились в начале метода.
Однако, это сильно сбивает с толку читателей,
особенно если метод длиннее, и вы не сразу обнаруживаете объявление.
В этом случае откажитесь от встраивания и разместите объявление заранее:

```ABAP
DATA value TYPE i.
IF has_entries = abap_true.
  value = 1.
ELSE.
  value = 2.
ENDIF.
```

> Подробнее в _Chapter 5: Formatting: Vertical Distance: Variable Declarations_ [Robert C. Martin's _Clean Code_].

### Не сцепливайте предварительные объявления

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Переменные](#переменные) > [Эта секция](#не-сцепливайте-предварительные-объявления)

```ABAP
DATA name TYPE seoclsname.
DATA reader TYPE REF TO reader.
```

Сцепливание предполагает, что определенные переменные логически связаны. 
Чтобы быть последовательным при их использовании нужно убедиться, что все переменные 
действительно связаны друг с другом, а затем ввести другие группы для добавления переменных. 
Это возможно, но в целом игра не стоит свеч.

Кроме того, цепочка излишне усложняет настройку форматирования и рефакторинг, 
потому что строки выглядят по-разному. Из-за этого их редактирование требует возни с двоеточиями, 
точками и запятыми, которые не стоят хлопот.

```ABAP
" anti-pattern
DATA:
  name   TYPE seoclsname,
  reader TYPE REF TO reader.
```

> Также см. [Не выравнивайте указания типов](#не-выравнивайте-указания-типов)  
> Если используется цепочка объявления данных, то используйте одну цепочку для каждой группы переменных.

### Предпочитайте REF TO вместо FIELD-SYMBOL

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Переменные](#переменные) > [Эта секция](#предпочитайте-ref-to-вместо-field-symbol)

> Этой секции [бросили вызов](https://github.com/SAP/styleguides/issues/115).
> `FIELD-SYMBOL`ы вроде бы, значительно быстрее
> при переборе внутренних таблиц,
> так что рекомендация использовать `REF TO`
> для этих случаев может ухудшить производительность.

```ABAP
LOOP AT components REFERENCE INTO DATA(component).
```

вместо аналогичного

```ABAP
" anti-pattern
LOOP AT components ASSIGNING FIELD-SYMBOL(<component>).
```

за исключением случаев, когда вам нужны именно символы поля

```ABAP
ASSIGN generic->* TO FIELD-SYMBOL(<generic>).
ASSIGN COMPONENT name OF STRUCTURE structure TO FIELD-SYMBOL(<component>).
ASSIGN (class_name)=>(static_member) TO FIELD-SYMBOL(<member>).
```

Как показывают обзоры кода, люди склонны выбирать одно или другое произвольным образом, 
«просто так», «потому что мы всегда создаем такие циклы» или «без особой причины». 
Из-за такого произвольного выбора читатель тратит время на размышления, почему один из них используется чаще, чем другой. 
Поэтому необходимо заменить эти произвольные решения обоснованными и точными решениями. 
Наша рекомендация основана на следующем рассуждении:

- Символы полей могут выполнять некоторые действия, которые недоступны ссылкам, например динамический доступ к компонентам структуры.
В то же время ссылки могут делать то, чего не могут символы поля, например создавать структуру данных с динамическим типом.
В общем, довольствоваться одним невозможно.

- В объектно-ориентированном ABAP ссылки встречаются повсюду, и их невозможно избежать,
так как любой объект является `REF TO <class-name>`.
При этом, символы полей строго требуются только в немногих особых случаях, связанных с динамической типизацией.
Таким образом, ссылки формируют естественное предпочтение в любой объектно-ориентированной программе.

Символы полей короче ссылок, но результирующая экономия памяти настолько мала, что ее можно смело пренебречь. 
Скорость тоже не имеет значения. Таким образом, нет никаких причин, связанных с производительностью, предпочесть одно другому.

> Подробнее читайте в статье
> [_Accessing Data Objects Dynamically_ in the ABAP Programming Guidelines](https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-US/index.htm?file=abendyn_access_data_obj_guidl.htm).

## Таблицы

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Эта секция](#таблицы)

### Используйте правильный тип таблицы

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Таблицы](#таблицы) > [Эта секция](#используйте-правильный-тип-таблицы)

- Используйте `HASHED` таблицы для **больших таблиц**.
которые **заполняются за один шаг**, **никогда не модифицируются** и **часто считываются по их ключу**.
Из-за потребления памяти и присущих им накладных расходов на обработку хеш-таблицы ценны только для
при больших объемах данных и большого количества доступов на чтение.
Каждое изменение содержимого таблицы требует дорогостоящего пересчета хэша,
поэтому не используйте их для таблиц, которые слишком часто изменяются.

- Используйте `SORTED` таблицы для **больших таблиц**
которые должны быть **отсортироваными в любое время**, которые **заполняются по частям** или **должны быть изменены**,
и **часто считываются по одному или нескольким полными или частичным ключам** или обрабатываются **в определенном порядке**.
Добавление, изменение или удаление содержимого требует поиска правильного места вставки,
но не требует корректировки остальной части индекса таблицы.
Отсортированные таблицы демонстрируют свою ценность только при большом количестве обращений на чтение.

- Используйте `STANDARD` таблицы для **небольших таблиц**, где индексация создает больше накладных расходов, чем пользы, и **"массивов"**, 
где вас либо вообще не волнует порядок строк, либо вы хотите обрабатывать их точно в том порядке, в котором они были добавлены. 
Кроме того, используйте их если требуется другой доступ к таблице, например, индексированный доступ и отсортированный доступ 
через "SORT" и "BINARY SEARCH".

> Это всего лишь приблизительные рекомендации.
> Подробнее в статье [_Selection of Table Category_ in the ABAP Language Help](https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-US/abenitab_kind.htm).

### Избегайте DEFAULT KEY

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Таблицы](#таблицы) > [Эта секция](#избегайте-default-key)

```ABAP
" anti-pattern
DATA itab TYPE STANDARD TABLE OF row_type WITH DEFAULT KEY.
```

Ключи по умолчанию часто добавляются только для того, чтобы заставить работать новые функциональные операторы.
Сами ключи по сути, обычно лишние и тратят ресурсы впустую.
Они могут даже привести к непонятным ошибкам, поскольку игнорируют числовые типы данных.
Например, операторы `SORT` и `DELETE ADJACENT` без явного указания списка полей будут использовать первичный ключ внутренней таблицы. 
Если при этом используется DEFAULT KEY это может привести к неожиданным результатам. Например, если используются 
числовые поля в ключе в сочетании с READ TABLE... BINARY и т. д.

Либо укажите ключевые компоненты явно

```ABAP
DATA itab2 TYPE STANDARD TABLE OF row_type WITH NON-UNIQUE KEY comp1 comp2.
```

или используйте `EMPTY KEY` если вам вообще не нужен ключ.

```ABAP
DATA itab1 TYPE STANDARD TABLE OF row_type WITH EMPTY KEY.
```

> Следуя [Horst Keller's blog on _Internal Tables with Empty Key_](https://blogs.sap.com/2013/06/27/abap-news-for-release-740-internal-tables-with-empty-key/)
> 
> **Внимание:** `SORT` по внутренним таблицам с `EMPTY KEY` (без явных полей сортировки) вообще не сортирует,
> но будут выданы синтаксические предупреждения в случае, если отсутствие ключа может быть определено статически.

### Предпочитайте INSERT INTO TABLE вместо APPEND TO

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Таблицы](#таблицы) > [Эта секция](#предпочитайте-insert-into-table-вместо-append-to)

```ABAP
INSERT VALUE #( ... ) INTO TABLE itab.
```

`INSERT INTO TABLE` работает со всеми типами таблиц и ключей.
Таким образом, вам будет проще провести рефакторинг определений типов и ключей таблицы, если ваши требования к производительности изменятся.

Используйте `APPEND TO` только если вы используете `STANDARD` таблицу в виде массива и 
хотите подчеркнуть, что добавленная запись должна быть последней строкой.

### Предпочитайте LINE_EXISTS вместо READ TABLE или LOOP AT

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Таблицы](#таблицы) > [Эта секция](#предпочитайте-line_exists-вместо-read-table-или-loop-at)

```ABAP
IF line_exists( my_table[ key = 'A' ] ).
```

выражает намерение яснее и короче, чем

```ABAP
" anti-pattern
READ TABLE my_table TRANSPORTING NO FIELDS WITH KEY key = 'A'.
IF sy-subrc = 0.
```

или даже

```ABAP
" anti-pattern
LOOP AT my_table REFERENCE INTO DATA(line) WHERE key = 'A'.
  line_exists = abap_true.
  EXIT.
ENDLOOP.
```

### Предпочитайте READ TABLE вместо LOOP AT

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Таблицы](#таблицы) > [Эта секция](#предпочитайте-read-table-вместо-loop-at)

```ABAP
READ TABLE my_table REFERENCE INTO DATA(line) WITH KEY key = 'A'.
```

выражает намерение яснее и короче, чем

```ABAP
" anti-pattern
LOOP AT my_table REFERENCE INTO DATA(line) WHERE key = 'A'.
  EXIT.
ENDLOOP.
```

или даже

```ABAP
" anti-pattern
LOOP AT my_table REFERENCE INTO DATA(line).
  IF line->key = 'A'.
    EXIT.
  ENDIF.
ENDLOOP.
```

### Предпочитайте LOOP AT WHERE вместо вложенных IF

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Таблицы](#таблицы) > [Эта секция](#предпочитайте-loop-at-where-вместо-вложенных-if)

```ABAP
LOOP AT my_table REFERENCE INTO DATA(line) WHERE key = 'A'.
```

выражает намерение яснее и короче, чем

```ABAP
LOOP AT my_table REFERENCE INTO DATA(line).
  IF line->key = 'A'.
    EXIT.
  ENDIF.
ENDLOOP.
```

### Избегайте ненужного чтения таблиц

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Таблицы](#таблицы) > [Эта секция](#избегайте-ненужного-чтения-таблиц)

Если вы _ожидаете_ что строка существует,
прочитайте таблицу только один раз и обработайте исключение,

```ABAP
TRY.
    DATA(row) = my_table[ key = input ].
  CATCH cx_sy_itab_line_not_found.
    RAISE EXCEPTION NEW /clean/my_data_not_found( ).
ENDTRY.
```

вместо того, чтобы засорять и замедлять
основной поток управления двойным считыванием

```ABAP
" anti-pattern
IF NOT line_exists( my_table[ key = input ] ).
  RAISE EXCEPTION NEW /clean/my_data_not_found( ).
ENDIF.
DATA(row) = my_table[ key = input ].
```

> Помимо улучшения производительности,
> это частный вариант более общего
> [Сосредоточьтесь либо на благополучном исходе либо на обработке ошибок, но не на том и другом одновременно](#сосредоточьтесь-либо-на-благополучном-исходе-либо-на-обработке-ошибок-но-не-на-том-и-другом-одновременно).

## Строки

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Эта секция](#строки)

### Используйте ` чтобы определить литералы

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Строки](#строки) > [Эта секция](#используйте--чтобы-определить-литералы)

```ABAP
CONSTANTS some_constant TYPE string VALUE `ABC`.
DATA(some_string) = `ABC`.  " --> TYPE string
```

Воздержитесь от использования `'`, так как это добавляет лишнее преобразование типов и сбивает читателя с толку
и он не знает имеет ли он дело с `CHAR` или `STRING`:

```ABAP
" anti-pattern
DATA some_string TYPE string.
some_string = 'ABC'.
```

`|` обычно тоже нормально, но не может использоваться для `CONSTANTS` и добавляет ненужные накладные расходы при указании фиксированного значения:

```ABAP
" anti-pattern
DATA(some_string) = |ABC|.
```

### Используйте | чтобы собрать текст

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Строки](#строки) > [Эта секция](#используйте--чтобы-собрать-текст)

```ABAP
DATA(message) = |Received HTTP code { status_code } with message { text }|.
```

Строковые шаблоны лучше выделяют, что является литералом, а что переменной,
особенно если вы вставляете в текст несколько переменных.

```ABAP
" anti-pattern
DATA(message) = `Received an unexpected HTTP ` && status_code && ` with message ` && text.
```

## Булевы значения

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Эта секция](#булевы-значения)

### Используйте булевы значения с умом

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Булевы значения](#булевы-значения) > [Эта секция](#используйте-булевы-значения-с-умом)

Мы часто сталкиваемся со случаями, когда булевы значения кажутся естественными

```ABAP
" anti-pattern
is_archived = abap_true.
```

пока изменение точки зрения не подскажет, что использовать перечисление было бы разумнее

```ABAP
archiving_status = /clean/archivation_status=>archiving_in_process.
```

Как правило, использовать булевы значения для различения типов элементов — плохая идея, 
потому что почти всегда вы будете сталкиваться со случаями, когда элементы не являются исключительно тем или другим.

```ABAP
assert_true( xsdbool( document->is_archived( ) = abap_true AND
                      document->is_partially_archived( ) = abap_true ) ).
```

Раздел [Разделите метод вместо использования булева входного параметра](#разделите-метод-вместо-использования-булева-входного-параметра)
хорошо объясняет, почему вы всегда должны быть против использования логических параметров.

> Подробнее в
> [1](http://www.beyondcode.org/articles/booleanVariables.html)

### Используйте ABAP_BOOL для булевых значений

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Булевы значения](#булевы-значения) > [Эта секция](#используйте-abap_bool-для-булевых-значений)

```ABAP
DATA has_entries TYPE abap_bool.
```

Не используйте универсальный тип `char1`.
Хотя он технически совместим, он скрывает тот факт, что мы имеем дело с булевой переменной.

Также избегайте других булевых типов, поскольку они часто имеют странные побочные эффекты.
Например, `boolean` поддерживает третье значение "undefined", что приводит к трудноуловимым ошибкам программирования.

В некоторых случаях вам может потребоваться элемент данных  словаря, например, для полей DynPro.
Здесь нельзя использовать `abap_bool`, поскольку он определен в пуле типов `abap`, а не в словаре данных.
В этом случае используйте `boole_d` или `xfeld`.
Создайте свой собственный элемент данных, если вам нужно пользовательское описание.

> ABAP может быть единственным языком программирования, который не имеет универсального логического типа данных.
> Тем не менее, его наличие обязательно. 
> Эта рекомендация основана на Руководстве по программированию на ABAP.

### Используйте ABAP_TRUE и ABAP_FALSE для сравнения

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Булевы значения](#булевы-значения) > [Эта секция](#используйте-abap_true-и-abap_false-для-сравнения)

```ABAP
has_entries = abap_true.
IF has_entries = abap_false.
```

Не используйте эквивалентные символы `'X'` и `' '` или `space`. 
Из-за них сложнее понять, что это логическое выражение:

```ABAP
" anti-pattern
has_entries = 'X'.
IF has_entries = space.
```

Избегайте сравнений с `INITIAL`. Это заставляет читателей вспоминать, что значение `abap_bool` по умолчанию равно `abap_false`:

```ABAP
" anti-pattern
IF has_entries IS NOT INITIAL.
```

> ABAP может быть единственным языком программирования, в котором нет встроенных "констант" для значений "истина" и "ложь".
> Тем не менее, их наличие обязательно. 
> Эта рекомендация основана на Руководстве по программированию на ABAP.

### Используйте XSDBOOL чтобы установить логические переменные

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Булевы значения](#булевы-значения) > [Эта секция](#используйте-xsdbool-чтобы-установить-логические-переменные)

```ABAP
DATA(has_entries) = xsdbool( line IS NOT INITIAL ).
```

Эквивалент `IF`-`THEN`-`ELSE` намного длиннее:

```ABAP
" anti-pattern
IF line IS INITIAL.
  has_entries = abap_false.
ELSE.
  has_entries = abap_true.
ENDIF.
```

`xsdbool` — подходит нам больше, потому что он напрямую создает `char1`, 
который лучше соответствует нашему логическому типу abap_bool. 
Эквивалентные функции `boolc` и `boolx` создают разные типы и требуют лишнего неявного преобразования типов.

Мы согласны с тем, что название `xsdbool` неудачно и вводит в заблуждение. 
В конце концов, нас совсем не интересуют части "Определения схемы XML", которые предлагает префикс "xsd".

Возможной альтернативой `xsdbool` является тернарная форма `COND`.
Ее синтаксис интуитивно понятен, но немного длиннее, потому что он без необходимости повторяет сегмент `THEN abap_true`
и требует знания неявного значения по умолчанию `abap_false`. 
Именно поэтому мы предлагаем его только в качестве вторичного решения.

```ABAP
DATA(has_entries) = COND abap_bool( WHEN line IS NOT INITIAL THEN abap_true ).
```

## Условия

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Эта секция](#условия)

### Постарайтесь сделать условия положительными

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Условия](#условия) > [Эта секция](#постарайтесь-сделать-условия-положительными)

```ABAP
IF has_entries = abap_true.
```

Для сравнения посмотрите, насколько трудно понять одно и то же утверждение, всего лишь изменив его на противоположное:

```ABAP
" anti-pattern
IF has_no_entries = abap_false.
```

"Постарайтесь" в названии раздела означает, что вы не должны доводить это до такой степени
когда в итоге получите что-то вроде [пустых ветвей IF](#не-допускайте-пустых-ветвей-if):

```ABAP
" anti-pattern
IF has_entries = abap_true.
ELSE.
  " only do something in the ELSE block, IF remains empty
ENDIF.
```

> Подробнее в _Chapter 17: Smells and Heuristics: G29: Avoid Negative Conditionals_ [Robert C. Martin's _Clean Code_].

### Предпочитайте IS NOT вместо NOT IS

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Условия](#условия) > [Эта секция](#предпочитайте-is-not-вместо-not-is)

```ABAP
IF variable IS NOT INITIAL.
IF variable NP 'TODO*'.
IF variable <> 42.
```

Отрицание логически эквивалентно
но требует проведения дополнительных преобразований "в уме",
что усложняет понимание.

```ABAP
" anti-pattern
IF NOT variable IS INITIAL.
IF NOT variable CP 'TODO*'.
IF NOT variable = 42.
```

> Более специфичный вариант
[Постарайтесь сделать условия положительными](#постарайтесь-сделать-условия-положительными). 
Так, как описано в разделе
[Alternative Language Constructs](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/index.htm?file=abenalternative_langu_guidl.htm)
в руководстве по программированию на ABAP.

### Подумайте об использовании предикативных вызовов для булевых методов

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Условия](#условия) > [Эта секция](#подумайте-об-использовании-предикативных-вызовов-для-булевых-методов)

Предикативный (или, другими словами, указывающий на свойство чего-либо) вызов для булевых методов

```ABAP
IF [ NOT ] condition_is_fulfilled( ).
```

не только очень компактен, но и позволяет сохранить код ближе к естественному языку, как выражение сравнения:

```ABAP
" anti-pattern
IF condition_is_fulfilled( ) = abap_true / abap_false.
```

Имейте в виду, что предикативный вызов метода `... meth( ) ...` это просто краткая форма `... meth( ) IS NOT INITIAL ...`, смотрите 
[Predicative Method Call](https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abenpredicative_method_calls.htm) 
в документации по ключевым словам ABAP. 
Вот почему короткая форма должна использоваться только для методов, возвращающих типы, где начальное значение это "ложь", а не "истина".

### Подумайте о декомпозиции сложных условий

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Условия](#условия) > [Эта секция](#подумайте-о-декомпозиции-сложных-условий)

Условия могут стать проще, если разложить их на элементарные части, из которых они состоят:

```ABAP
DATA(example_provided) = xsdbool( example_a IS NOT INITIAL OR
                                  example_b IS NOT INITIAL ).

DATA(one_example_fits) = xsdbool( applies( example_a ) = abap_true OR
                                  applies( example_b ) = abap_true OR
                                  fits( example_b ) = abap_true ).

IF example_provided = abap_true AND
   one_example_fits = abap_true.
```

вместо того, чтобы оставить их вместе:

```ABAP
" anti-pattern
IF ( example_a IS NOT INITIAL OR
     example_b IS NOT INITIAL ) AND
   ( applies( example_a ) = abap_true OR
     applies( example_b ) = abap_true OR
     fits( example_b ) = abap_true ).
```

> Используйте ABAP Development Tools quick fixes для быстрого извлечения условий и создания переменных, как показано выше.

### Подумайте об извлечении сложных условий

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Условия](#условия) > [Эта секция](#подумайте-об-извлечении-сложных-условий)

Почти всегда полезно выносить сложные условия в их собственные методы:

```ABAP
IF is_provided( example ).

METHOD is_provided.
  DATA(is_filled) = xsdbool( example IS NOT INITIAL ).
  DATA(is_working) = xsdbool( applies( example ) = abap_true OR
                              fits( example ) = abap_true ).
  result = xsdbool( is_filled = abap_true AND
                    is_working = abap_true ).
ENDMETHOD.
```

## Если

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Эта секция](#если)

### Не допускайте пустых ветвей IF

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Если](#если) > [Эта секция](#не-допускайте-пустых-ветвей-if)

```ABAP
IF has_entries = abap_false.
  " do some magic
ENDIF.
```

короче и понятнее, чем

```ABAP
" anti-pattern
IF has_entries = abap_true.
ELSE.
  " do some magic
ENDIF.
```

### Предпочитайте CASE вместо ELSE IF для нескольких альтернативных условий

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Если](#если) > [Эта секция](#предпочитайте-case-вместо-else-if-для-нескольких-альтернативных-условий)

```ABAP
CASE type.
  WHEN type-some_type.
    " ...
  WHEN type-some_other_type.
    " ...
  WHEN OTHERS.
    RAISE EXCEPTION NEW /clean/unknown_type_failure( ).
ENDCASE.
```

`CASE` позволяет легко увидеть набор исключающих друг друга альтернатив.
Еще он может быть быстрее, чем серия `IF`ов, потому что оно может переводиться в другую команду микропроцессора
вместо серии последовательно вычисленных условий.
Вы можете быстро добавлять новые условия, без необходимости повторять проверяемую переменную снова и снова.
Кроме того, он предотвращает некоторые ошибки, которые могут возникнуть при случайном вложении `IF`-`ELSEIF`ов.

```ABAP
" anti-pattern
IF type = type-some_type.
  " ...
ELSEIF type = type-some_other_type.
  " ...
ELSE.
  RAISE EXCEPTION NEW /dirty/unknown_type_failure( ).
ENDIF.
```

### Сохраняйте глубину вложенности низкой

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Если](#если) > [Эта секция](#сохраняйте-глубину-вложенности-низкой)

```ABAP
" anti-pattern
IF <this>.
  IF <that>.
  ENDIF.
ELSE.
  IF <other>.
  ELSE.
    IF <something>.
    ENDIF.
  ENDIF.
ENDIF.
```

Вложенные `IF`ы очень быстро становятся трудными для понимания и требуют экспоненциального количества тестов для полного покрытия.

Деревья решений обычно можно разделить, сформировав подметоды и введя булевы вспомогательные переменные.

Другие случаи могут быть упрощены путем объединения `IF`ов, например

```ABAP
IF <this> AND <that>.
```

вместо без необходимости вложенных

```ABAP
" anti-pattern
IF <this>.
  IF <that>.
```

## Регулярные выражения

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Эта секция](#регулярные-выражения)

### Предпочитайте более простые методы регулярным выражениям

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Регулярные выражения](#регулярные-выражения) > [Эта секция](#предпочитайте-более-простые-методы-регулярным-выражениям)

```ABAP
IF input IS NOT INITIAL.
" IF matches( val = input  regex = '.+' ).

WHILE contains( val = input  sub = 'abc' ).
" WHILE contains( val = input  regex = 'abc' ).
```

Регулярные выражения очень быстро становятся трудными для понимания.
В простых случаях обычно легче обходиться без них.

Также, регулярные выражения обычно потребляют больше памяти и занимают больше времени обработки.
Это связано с тем, что они должны быть проанализированы в дереве выражений и скомпилированы во время выполнения 
в исполняемый сопоставитель (matcher).
Простые решения могут состоять из простого цикла и временной переменной.

### Предпочитайте базовые проверки регулярным выражениям

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Регулярные выражения](#регулярные-выражения) > [Эта секция](#предпочитайте-базовые-проверки-регулярным-выражениям)

```ABAP
CALL FUNCTION 'SEO_CLIF_CHECK_NAME'
  EXPORTING
    cls_name = class_name
  EXCEPTIONS
    ...
```

вместо того, чтобы заново изобретать вещи

```ABAP
" anti-pattern
DATA(is_valid) = matches( val     = class_name
                          pattern = '[A-Z][A-Z0-9_]{0,29}' ).
```

> Кажется, существует естественная склонность закрывать глаза на принцип «Не повторяйтесь» (DRY)
> когда речь идет о регулярных выражениях,
> см. раздел _Chapter 17: Smells and Heuristics: General: G5: Duplication_ в [Robert C. Martin's _Clean Code_].

### Рассмотрите возможность сборки сложных регулярных выражений

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Регулярные выражения](#регулярные-выражения) > [Эта секция](#рассмотрите-возможность-сборки-сложных-регулярных-выражений)

```ABAP
CONSTANTS class_name TYPE string VALUE `CL\_.*`.
CONSTANTS interface_name TYPE string VALUE `IF\_.*`.
DATA(object_name) = |{ class_name }\|{ interface_name }|.
```

Некоторые сложные регулярные выражения становятся проще
когда вы демонстрируете читателю, как они строятся из более элементарных частей.

## Классы

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Эта секция](#классы)

### Классы: Объектная ориентация

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Классы](#классы) > [Эта секция](#классы-объектная-ориентация)

#### Предпочитайте объекты статическим классам

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Классы](#классы) > [Классы: Объектная ориентация](#классы-объектная-ориентация) > [Эта секция](#предпочитайте-объекты-статическим-классам)

Статические классы отвергают все преимущества объектно-ориентированного программирования. 
В частности, они делают практически невозможной замену продуктивных зависимостей тестовыми двойниками в модульных тестах.

Если вы раздумываете о том, делать ли класс или метод статическими, почти всегда ответ будет: нет.

Одним допустимым исключением из этого правила являются простые классы утилит.
Их методы облегчают взаимодействие с некоторыми типами ABAP.
Они не только полностью не имеют состояния, но и настолько просты, что выглядят как операторы ABAP или встроенные функции.
Отличительной чертой таких классов является то, что те, кто их использует так сильно привязывают их к своему коду,
что они на самом деле не хотят мокать их в модульных тестах.

```ABAP
CLASS /clean/string_utils DEFINITION [...].
  CLASS-METHODS trim
   IMPORTING
     string        TYPE string
   RETURNING
     VALUE(result) TYPE string.
ENDCLASS.

METHOD retrieve.
  DATA(trimmed_name) = /clean/string_utils=>trim( name ).
  result = read( trimmed_name ).
ENDMETHOD.
```

#### Предпочитайте композицию наследованию

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Классы](#классы) > [Классы: Объектная ориентация](#классы-объектная-ориентация) > [Эта секция](#предпочитайте-композицию-наследованию)

Избегайте построения иерархий классов с наследованием. Вместо этого отдавайте предпочтение композиции.

Чистое наследование сложно спроектировать, потому что нужно соблюдать такие правила
как [Принцип подстановки Барбары Лисков](https://en.wikipedia.org/wiki/Liskov_substitution_principle).
Для того, чтобы его понять вы должны знать основополагающие принципы, лежащие в основе иерархии, и использовать их.
Наследование ограничивает повторное использование, потому что методы, как правило, доступны только для подклассов.
Кроме того это усложняет рефакторинг, так как перемещение или изменение элементов обычно требует изменений во всем дереве иерархии.

Композиция означает, что вы разрабатываете небольшие независимые объекты, каждый из которых служит определенной цели. 
Эти объекты могут быть объединены в более сложные объекты с помощью простых моделей делегирования и фасада. 
Композиция может приводить к созданию большего количества классов, но это единственный ее недостаток.

Однако, не позволяйте этому правилу отбить у вас желание использовать наследование тогда, когда это имеет смысл. 
Существуют хорошие способы примерения наследования, например [шаблон проектирования Компоновщик](https://en.wikipedia.org/wiki/Composite_pattern).
Просто спросите себя, действительно ли в вашем случае наследование принесет больше пользы, чем вреда. 
Если вы сомневаетесь, то обычно композиция является самым безопасным вариантом.

> В подразделе [Интерфейсы против абстрактных классов](sub-sections/InterfacesVsAbstractClasses.md)
сравниваются некоторые детали.

#### Не смешивайте парадигмы с сохранением состояния и без сохранения состояния в одном классе

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Классы](#классы) > [Классы: Объектная ориентация](#классы-объектная-ориентация) > [Эта секция](#не-смешивайте-парадигмы-с-сохранением-состояния-и-без-сохранения-состояния-в-одном-классе)

Не смешивайте парадигмы программирования без сохранения состояния и с сохранением состояния в одном классе.

В программировании без сохранения состояния методы получают входные данные и заполняют выходные данные 
_без каких-либо побочных эффектов_. Следовательно, методы возвращают один и тот же результат независимо от того, 
когда и в каком порядке они вызываются.

```ABAP
CLASS /clean/xml_converter DEFINITION PUBLIC FINAL CREATE PUBLIC.
  PUBLIC SECTION.
    METHODS convert
      IMPORTING
        file_content  TYPE xstring
      RETURNING
        VALUE(result) TYPE /clean/some_inbound_message.
ENDCLASS.

CLASS /clean/xml_converter IMPLEMENTATION.
  METHOD convert.
    cl_proxy_xml_transform=>xml_xstring_to_abap(
      EXPORTING
        xml       = file_content
        ext_xml   = abap_true
        svar_name = 'ROOT_NODE'
      IMPORTING
        abap_data = result ).
   ENDMETHOD.
ENDCLASS.
```

В программировании с сохранением состояния мы манипулируем внутренним состоянием объектов с помощью их методов. 
Это означает, что в такой парадигме _полно побочных эффектов_.

```ABAP
CLASS /clean/log DEFINITION PUBLIC CREATE PUBLIC.
  PUBLIC SECTION.
    METHODS add_message IMPORTING message TYPE /clean/message.
  PRIVATE SECTION.
    DATA messages TYPE /clean/message_table.
ENDCLASS.

CLASS /clean/log IMPLEMENTATION.
  METHOD add_message.
    INSERT message INTO TABLE messages.
  ENDMETHOD.
ENDCLASS.
```

Обе парадигмы хороши и имеют свои области применения. 
Однако их смешивание в одном объекте делает код трудным для понимания 
и обреченным на сбой из-за неясных ошибок переносf и проблем с синхронностью. 
Не делай этого.

### Область видимости

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Классы](#классы) > [Эта секция](#область-видимости)

#### Глобальный по умолчанию, локальный только при необходимости

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Классы](#классы) > [Область видимости](#область-видимости) > [Эта секция](##глобальный-по-умолчанию-локальный-только-при-необходимости)

Работайте с глобальными классами.
Используйте локальные классы только там, где это уместно.

> Глобальные классы — это те, которые видны в словаре данных.
> Локальные классы находятся внутри includ'а другого объекта 
> и видны только этому другому объекту.

Локальные классы подходят

- для очень специфических приватных структур данных, 
например, итератор для глобальных данных класса, 
который нужен только здесь;

- для извлечения сложного приватного алгоритма,
например, чтобы отделить состоящий из нескольких методов алгоритм сортировки-агрегирования, 
нацеленный на решение конкретной задачи, от остального кода в вашем классе;

- чтобы позволить замокать некоторые элементы глобального класса, 
например, путем выделения всего доступа к базе данных в отдельный локальный класс, 
который можно заменить фиктивным тестовым двойником в модульных тестах.

Локальные классы затрудняют повторное использование, потому что они не могут быть использованы где-либо еще.
Хотя их легко извлечь и сделать на их основе глобальный класс, люди обычно даже не могут их найти,
что в свою очередь приводит к нежелательному дублированию кода.
Ориентация, навигация и отладка в очень больших локальных классах
являются утомительными и раздражающими.

Поскольку ABAP выполняет блокировку на уровне includ'а, люди не смогут одновременно работать, например над
разными локальными классами, находящимися в одном includ'е 
(что было бы возможно, если бы они были отдельными глобальными классами).

Пересмотрите свое использование локальных классов, если

- ваш локальный include содержит десятки классов и тысячи строк кода;
- вы думаете о глобальных классах как о "пакетах", которые содержат другие классы;
- ваш глобальный класс вырождается в пустую оболочку;
- вы найдете дублирующийся код, повторяющийся в отдельных локальных includ'ах;
- ваши разработчики начинают блокировать друг друга и не могут работать параллельно;
- ваш список работ для выполения становится огромным, потому что ваши команды больше не понимают локальные includ'ы друг друга.

#### FINAL если не предназначен для наследования

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Классы](#классы) > [Область видимости](#область-видимости) > [Эта секция](#final-если-не-предназначен-для-наследования)

Если класс явно не предназначен для наследования, сделайте его `FINAL`.

При проектировании взаимодействия классов 
в первую очередь вы должны [предпочитать композицию наследованию](#предпочитайте-композицию-наследованию). 
Выбор в пользу наследования не должен быть легкомысленным, поскольку он предполагает размышления о модификаторах доступа, 
таких как `PROTECTED` или `PRIVATE`, а также о [принципе подстановки Барбары Лисков](https://en.wikipedia.org/wiki/Liskov_substitution_principle), 
к тому же, многие внутренние части дизайна будут "заморожены". 
Поэтому, если вы разрабатывали свои классы без учета этих вещей, вы должны предотвратить непреднамеренное наследование, сделав свой класс `FINAL`.

Конечно, у наследования есть несколько хороших применений, например [Компоновщик (шаблон проектирования)](https://en.wikipedia.org/wiki/Composite_pattern).
Бизнес-надстройки также могут быть более полезными, позволяя создавать подклассы, 
что дает клиенту возможность повторно использовать большую часть исходного кода. 
Обратите внимание, однако, что во всех этих случаях наследование заложено с самого начала.

Классы, которые не [реализуют интерфейсы](#публичные-методы-экземпляра-должны-быть-частью-интерфейса)
следует сделать не `FINAL`, чтобы позволить другим замокать их в своих модульных тестах.

#### PRIVATE по умолчанию, PROTECTED только если нужно

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Классы](#классы) > [Область видимости](#область-видимости) > [Эта секция](#private-по-умолчанию-protected-только-если-нужно)

Делайте атрибуты, методы и другие члены класса `PRIVATE` по умолчанию.

Сделайте их `PROTECTED`, только если вы хотите дать возможность подклассам переопределить их.

Внутренние части классов должны быть доступны другим только при явной необходимости. 
Это относится не только ко внешним вызовам, но и к подклассам. 
Чрезмерная доступность информации может вызвать незаметные ошибки из-за неожиданных переопределений и затруднить рефакторинг, 
поскольку внешние программы считывают текущие значения атрибутов, но эти значения позже могут быть изменены.

#### Рассмотрите возможность использования неизменяемого объекта, вместо добавления геттера

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Классы](#классы) > [Область видимости](#область-видимости) > [Эта секция](#рассмотрите-возможность-использования-неизменяемого-объекта-вместо-добавления-геттера)

Неизменяемый (immutable) объект, это объект, который никогда не меняется после его создания.
Для объектов такого рода рассмотрите возможность использования публичных атрибутов, доступных только для чтения, вместо создания геттеров.

```ABAP
CLASS /clean/some_data_container DEFINITION.
  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        a TYPE i
        b TYPE c
        c TYPE d.
    DATA a TYPE i READ-ONLY.
    DATA b TYPE c READ-ONLY.
    DATA c TYPE d READ-ONLY.
ENDCLASS.
```

вместо

```ABAP
CLASS /dirty/some_data_container DEFINITION.
  PUBLIC SECTION.
    METHODS get_a ...
    METHODS get_b ...
    METHODS get_c ...
  PRIVATE SECTION.
    DATA a TYPE i.
    DATA b TYPE c.
    DATA c TYPE d.
ENDCLASS.
```

> **Внимание**: для объектов, которые **изменяют** свои атрибуты, не используйте публичные read-only атрибуты. 
> В противном случае эти атрибуты должны всегда поддерживаться в актуальном состоянии, 
> независимо от того, требуется ли их значение для другого кода или нет.

#### Используйте READ-ONLY с осторожностью

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Классы](#классы) > [Область видимости](#область-видимости) > [Эта секция](#используйте-read-only-с-осторожностью)

Многие современные языки программирования, особенно Java, рекомендуют везде где это целесообразно
устанавливать для членов класса доступ только для чтения, чтобы избежать случайных побочных эффектов.

Хотя ABAP и _предлагает_ дополнение `READ-ONLY` для объявлении данных, мы рекомендуем использовать его с осторожностью.

Во-первых, дополнение доступно только в `PUBLIC SECTION`, что сильно ограничивает возмоности его применения.
Вы не можете добавить его ни к защищенным, ни к приватным членам класса, ни к локальным переменным в методе.

Во-вторых, добавление работает несколько иначе, чем можно было бы ожидать имея опыт программирования на других языках:
READ-ONLY данные по-прежнему могут быть изменены любым методом внутри самого класса, его друзьях или подклассах.
Это противоречит более распространенному в других языках поведению, где элемент, написанный однажды, никогда больше не изменяется. 
Эта разница может привести к неприятным сюрпризам.

> Во избежание недоразумений: напоминаем вам, что защита переменных от случайного изменения является хорошей практикой. 
> Мы бы порекомендовали вам применить эту практику и к ABAP, если бы существовала соответствующая инструкция.

### Конструкторы

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Классы](#классы) > [Эта секция](#конструкторы)

#### Предпочитайте NEW вместо CREATE OBJECT

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Классы](#классы) > [Конструкторы](#конструкторы) > [Эта секция](#предпочитайте-new-вместо-create-object)
```ABAP
DATA object TYPE REF TO /clean/some_number_range.
object = NEW #( '/CLEAN/CXTGEN' )
...
DATA(object) = NEW /clean/some_number_range( '/CLEAN/CXTGEN' ).
...
DATA(object) = CAST /clean/number_range( NEW /clean/some_number_range( '/CLEAN/CXTGEN' ) ).
```

вместо излишне длинного

```ABAP
" anti-pattern
DATA object TYPE REF TO /dirty/some_number_range.
CREATE OBJECT object
  EXPORTING
    number_range = '/DIRTY/CXTGEN'.
```

конечно, за исключением случаев, когда вам нужно указать тип динамически

```ABAP
CREATE OBJECT number_range TYPE (dynamic_type)
  EXPORTING
    number_range = '/CLEAN/CXTGEN'.
```

#### Если ваш глобальный класс CREATE PRIVATE, сделайте его CONSTRUCTOR публичным

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Классы](#классы) > [Конструкторы](#конструкторы) > [Эта секция](#Если-ваш-глобальный-класс-create-private-сделайте-его-constructor-публичным)

```ABAP
CLASS /clean/some_api DEFINITION PUBLIC FINAL CREATE PRIVATE.
  PUBLIC SECTION.
    METHODS constructor.
```

Мы согласны с тем, что это противоречит самому себе.
Однако, согласно статье 
[ _Instance Constructor_ of the ABAP Help](https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-US/abeninstance_constructor_guidl.htm),
указание `CONSTRUCTOR` в `PUBLIC SECTION` требуется, чтобы гарантировать правильную компиляцию и проверку синтаксиса.

Это относится только к глобальным классам.
В локальных классах делайте конструктор закрытым, каким он и должен быть.

#### Предпочитайте несколько статических методов созданию необязательных параметров

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Классы](#классы) > [Конструкторы](#конструкторы) > [Эта секция](#предпочитайте-несколько-статических-методов-созданию-необязательных-параметров)

```ABAP
CLASS-METHODS describe_by_data IMPORTING data TYPE any [...]
CLASS-METHODS describe_by_name IMPORTING name TYPE any [...]
CLASS-METHODS describe_by_object_ref IMPORTING object_ref TYPE REF TO object [...]
CLASS-METHODS describe_by_data_ref IMPORTING data_ref TYPE REF TO data [...]
```

ABAP не поддерживает [перегрузку](https://en.wikipedia.org/wiki/Function_overloading).
Используйте разные варианты имени, вместо необязательных параметров для достижения желаемой семантики.

```ABAP
" anti-pattern
METHODS constructor
  IMPORTING
    data       TYPE any OPTIONAL
    name       TYPE any OPTIONAL
    object_ref TYPE REF TO object OPTIONAL
    data_ref   TYPE REF TO data OPTIONAL
  [...]
```

Раздел 
[_Разделите методы вместо добавления OPTIONAL параметров_](#разделите-методы-вместо-добавления-optional-параметров)
объясняет причину этой рекомендации.

Рассмотрите возможность преобразования сложных конструкций в одну многоступенчатую конструкцию используя
[Строитель (шаблон проектирования)](https://en.wikipedia.org/wiki/Builder_pattern).

#### Используйте описательные имена для нескольких методов создания

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Классы](#классы) > [Конструкторы](#конструкторы) > [Эта секция](#используйте-описательные-имена-для-нескольких-методов-создания)

Хорошими словами для начала имени методов создания чело-либо: `new_`, `create_`, и `construct_`.
Люди интуитивно связывают их с построением объектов.
Они также хорошо сочетаются с такими глагольными словосочетаниями, как `new_from_template`, `create_as_copy`, или `create_by_name`.

```ABAP
CLASS-METHODS new_describe_by_data IMPORTING p_data TYPE any [...]
CLASS-METHODS new_describe_by_name IMPORTING p_name TYPE any [...]
CLASS-METHODS new_describe_by_object_ref IMPORTING p_object_ref TYPE REF TO object [...]
CLASS-METHODS new_describe_by_data_ref IMPORTING p_data_ref TYPE REF TO data [...]
```

вместо чего-то бессмысленного, как

```ABAP
" anti-pattern
CLASS-METHODS create_1 IMPORTING p_data TYPE any [...]
CLASS-METHODS create_2 IMPORTING p_name TYPE any [...]
CLASS-METHODS create_3 IMPORTING p_object_ref TYPE REF TO object [...]
CLASS-METHODS create_4 IMPORTING p_data_ref TYPE REF TO data [...]
```

#### Создавайте синглтоны только там, где несколько экземпляров не имеют смысла

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Классы](#классы) > [Конструкторы](#конструкторы) > [Эта секция](#создавайте-синглтоны-только-там-где-несколько-экземпляров-не-имеют-смысла)

```ABAP
METHOD new.
  IF singleton IS NOT BOUND.
    singleton = NEW /clean/my_class( ).
  ENDIF.
  result = singleton.
ENDMETHOD.
```

Применяйте шаблон проектирования singleton, когда ваш объектно-ориентированный дизайн указывает на то, 
что иметь второй экземпляр чего-либо нет смысла. 
Используйте его для того, чтобы быть уверенным, что каждый потребитель работает с одной и той же вещью, 
в том же состоянии и с одними и теми же данными.

Не используйте шаблон singleton по привычке или из соображений производительности. 
Это наиболее часто используемый и неправильно применяемый шаблон, который приводит к неожиданным перекрестным эффектам и излишне усложняет тестирование. 
Если нет причин, обусловленных дизайном, для создания объекта в единичном экземпляре, пусть это решение принимает потребитель. 
Тот же результат он сможет получить, прибегнув к внешним по отношению к конструктору средствам, например, к фабрике.

## Методы

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Эта секция](#методы)

Эти правила применяются к методам в классах и к функциональным модулям.

### Вызовы

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Эта секция](#вызовы)

#### Не вызывайте статические методы через переменные экземпляра

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Вызовы](#вызовы) > [Эта секция](#не-вызывайте-статические-методы-через-переменные-экземпляра)

Для вызова статического метода используйте
```ABAP
cl_my_class=>static_method( ).
```

Вместо того, чтобы вызывать его через переменную экземпляра `cl_my_class`
```ABAP
" anti-pattern
lo_my_instance->static_method( ).
```

Статический метод привязан к самому классу, и его вызов через переменную экземпляра потенциально может привести к путанице.

Вызывать статический метод внутри другого статического метода того же класса не указывая имя этого класса - нормально.

```ABAP
METHOD static_method.
  another_static_method( ).
  yet_another( ).
ENDMETHOD.
```

Однако внутри метода объекта, при вызове статического метода того же класса, уточняйте вызов добавляя имя класса:

```ABAP
CLASS cl_my_class IMPLEMENTATION.

  METHOD instance_method.
    cl_my_class=>a_static_method( ).
    another_instance_method( ).
  ENDMETHOD.

  ...
```

#### Предпочитайте функциональные вызовы процедурным

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Вызовы](#вызовы) > [Эта секция](#предпочитайте-функциональные-вызовы-процедурным)

```ABAP
modify->update( node           = /clean/my_bo_c=>node-item
                key            = item->key
                data           = item
                changed_fields = changed_fields ).
```

вместо слишком длинного

```ABAP
" anti-pattern
CALL METHOD modify->update
  EXPORTING
    node           = /dirty/my_bo_c=>node-item
    key            = item->key
    data           = item
    changed_fields = changed_fields.
```

Если динамическая типизация запрещает функциональные вызовы, используйте процедурный стиль. 

```ABAP
CALL METHOD modify->(method_name)
  EXPORTING
    node           = /clean/my_bo_c=>node-item
    key            = item->key
    data           = item
    changed_fields = changed_fields.
```

Многие из подробных правил, приведенных ниже, являются лишь более специфическими вариациями этого совета.

#### Не указывайте RECEIVING

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Вызовы](#вызовы) > [Эта секция](#не-указывайте-receiving)

```ABAP
DATA(sum) = aggregate_values( values ).
```

вместо излишне длинного

```ABAP
" anti-pattern
aggregate_values(
  EXPORTING
    values = values
  RECEIVING
    result = DATA(sum) ).
```

#### Не указывайте необязательное ключевое слово EXPORTING

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Вызовы](#вызовы) > [Эта секция](#не-указывайте-необязательное-ключевое-слово-exporting)

```ABAP
modify->update( node           = /clean/my_bo_c=>node-item
                key            = item->key
                data           = item
                changed_fields = changed_fields ).
```

вместо излишне длинного

```ABAP
" anti-pattern
modify->update(
  EXPORTING
    node           = /dirty/my_bo_c=>node-item
    key            = item->key
    data           = item
    changed_fields = changed_fields ).
```

#### Не указывайте имя параметра при вызовах с одним параметром

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Вызовы](#вызовы) > [Эта секция](#omit-the-parameter-name-in-single-parameter-calls)

```ABAP
DATA(unique_list) = remove_duplicates( list ).
```

вместо излишне длинного

```ABAP
" anti-pattern
DATA(unique_list) = remove_duplicates( list = list ).
```

Порой, названия метода недостаточно для понимания, и указание имени параметра может сделать код более понятным:

```ABAP
car->drive( speed = 50 ).
update( asynchronous = abap_true ).
```

#### Не указывайте ссылку на себя me при вызове атрибута или метода экземпляра

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Вызовы](#вызовы) > [Эта секция](#не-указывайте-ссылку-на-себя-me-при-вызове-атрибута-или-метода-экземпляра)

Поскольку ссылка на себя `me->` неявно устанавливается системой, опустите ее при вызове атрибута или метода экземпляра.

```ABAP
DATA(sum) = aggregate_values( values ).
```

вместо излишне длинного

```ABAP
" anti-pattern
DATA(sum) = aggregate_values( me->values ).
```

```ABAP
" anti-pattern
DATA(sum) = me->aggregate_values( values ).
```

разумеется, `me->`  можно опустить только если у вас нет конфликта области видимости 
между локальной переменной или параметром импорта и атрибутом экземпляра

```ABAP
me->logger = logger.
```

### Методы: Объектная ориентация

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Эта секция](#методы-объектная-ориентация)

#### Предпочитайте экземпляр статическим методам

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Методы: Объектная ориентация](#методы-объектная-ориентация) > [Эта секция](#предпочитайте-экземпляр-статическим-методам)

По умолчанию методы должны быть членами экземпляра.
Методы экземпляра лучше отражают "объектность" класса.
Их легче замокать в модульных тестах.

```ABAP
METHODS publish.
```

Методы должны быть статическими только в исключительных случаях, например статические методы создания.

```ABAP
CLASS-METHODS create_instance
  RETURNING
    VALUE(result) TYPE REF TO /clean/blog_post.
```

#### Публичные методы экземпляра должны быть частью интерфейса

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Методы: Объектная ориентация](#методы-объектная-ориентация) > [Эта секция](#публичные-методы-экземпляра-должны-быть-частью-интерфейса)

Публичные методы экземпляра всегда должны быть частью интерфейса. 
Они разделяют зависимости и упрощают их мокинг при модульном тестировании.

```ABAP
METHOD /clean/blog_post~publish.
```

В контексте чисто объектного подхода не имеет особого смысла делать метод общедоступным без интерфейса — 
за некоторыми исключениями, такими как классы перечисления, 
которые никогда не имеют альтернативной реализации и никогда не мокаются в тестовых примерах.

> Раздел [Интерфейсы против абстрактных классов](sub-sections/InterfacesVsAbstractClasses.md)
описывает, почему это относится и к классам, которые переопределяют унаследованные методы.

### Количество параметров

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Эта секция](#количество-параметров)

#### Стремитесь к нескольким IMPORTING параметрам, лучше всего меньше трех

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Количество параметров](#количество-параметров) > [Эта секция](#стремитесь-к-нескольким-IMPORTING-параметрам-лучше-всего-меньше-трех)

```ABAP
FUNCTION seo_class_copy
  IMPORTING
    clskey      TYPE seoclskey
    new_clskey  TYPE seoclskey
    config      TYPE class_copy_config
  EXPORTING
    ...
```

будет намного понятнее, чем

```ABAP
" anti-pattern
FUNCTION seo_class_copy
  IMPORTING
    clskey                 TYPE seoclskey
    new_clskey             TYPE seoclskey
    access_permission      TYPE seox_boolean DEFAULT seox_true
    VALUE(save)            TYPE seox_boolean DEFAULT seox_true
    VALUE(suppress_corr)   TYPE seox_boolean DEFAULT seox_false
    VALUE(suppress_dialog) TYPE seox_boolean DEFAULT seox_false
    VALUE(authority_check) TYPE seox_boolean DEFAULT seox_true
    lifecycle_manager      TYPE REF TO if_adt_lifecycle_manager OPTIONAL
    lock_handle            TYPE REF TO if_adt_lock_handle OPTIONAL
    VALUE(suppress_commit) TYPE seox_boolean DEFAULT seox_false
  EXPORTING
    ...
```

Входные параметры, если их слишком много, усложняют метод, 
поскольку он должен обрабатывать экспоненциальное количество комбинаций. 
Большое количество параметров является признаком того, что метод, вероятно, выполняет более одной функции.

Вы можете уменьшить количество параметров, объединив их по смыслу в структуры или объекты.

#### Разделите методы вместо добавления OPTIONAL параметров

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Количество параметров](#количество-параметров) > [Эта секция](#разделяйте-методы-вместо-добавления-optional-параметров)

```ABAP
METHODS do_one_thing IMPORTING what_i_need TYPE string.
METHODS do_another_thing IMPORTING something_else TYPE i.
```

для того, чтобы достичь желаемой семантики, поскольку ABAP не поддерживает [перегрузку](https://en.wikipedia.org/wiki/Function_overloading).

```ABAP
" anti-pattern
METHODS do_one_or_the_other
  IMPORTING
    what_i_need    TYPE string OPTIONAL
    something_else TYPE i OPTIONAL.
```

Необязательные параметры сбивают с толку тех, кто хочет вызвать метод:

- Какие из них действительно необходимы?
- Какие комбинации этих параметров допустимы?
- Какие исключают друг друга?

Несколько методов с параметрами, адаптированными для каждого варианта использования, позволяют избежать путаницы, четко документируя, какие комбинации параметров являются допустимыми и ожидаемыми.

#### Используйте PREFERRED PARAMETER с осторожностью

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Количество параметров](#количество-параметров) > [Эта секция](#используйте-preferred-parameter-с-осторожностью)

С опцией `PREFERRED PARAMETER` сложнее сказать, какие параметры фактически заполнены, 
и еще сложнее понять код. 
Минимизируя количество параметров, особенно необязательных, 
вы автоматически уменьшаете потребность в использовании `PREFERRED PARAMETER`.

#### RETURN, EXPORT, или CHANGE только одного параметра

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Количество параметров](#количество-параметров) > [Эта секция](#return-export-или-change-только-одного-параметра)

Хороший метод делает _одну вещь_, и это должно быть отражено в методе тем, что он возвращает ровно одну вещь. 
Если выходные параметры вашего метода _не_ образуют логическую сущность, 
то ваш метод делает несколько вещей сразу, и вам следует разделить его.

В некоторых случаях выходные данные представляют собой логическую сущность, состоящую из нескольких вещей. 
В таких случаях лучше возвращать структуру или объект:

```ABAP
TYPES:
  BEGIN OF check_result,
    result      TYPE result_type,
    failed_keys TYPE /bobf/t_frw_key,
    messages    TYPE /bobf/t_frw_message,
  END OF check_result.

METHODS check_business_partners
  IMPORTING
    business_partners TYPE business_partners
  RETURNING
    VALUE(result)     TYPE check_result.
```

вместо

```ABAP
" anti-pattern
METHODS check_business_partners
  IMPORTING
    business_partners TYPE business_partners
  EXPORTING
    result            TYPE result_type
    failed_keys       TYPE /bobf/t_frw_key
    messages          TYPE /bobf/t_frw_message.
```

Особенно в сравнении с несколькими EXPORTING параметрами, это позволяет людям использовать функциональный стиль вызова, 
избавляет вас от необходимости думать о `IS SUPPLIED` и предотвращает ситуацию, когда можно случайно забыть 
получить важную информацию об ошибке `ERROR_OCCURRED`.

Вместо использования нескольких необязательных выходных параметров разделите метод на несколько, используя осмысленные шаблоны вызовов:

```ABAP
TYPES:
  BEGIN OF check_result,
    result      TYPE result_type,
    failed_keys TYPE /bobf/t_frw_key,
    messages    TYPE /bobf/t_frw_message,
  END OF check_result.

METHODS check
  IMPORTING
    business_partners TYPE business_partners
  RETURNING
    VALUE(result)     TYPE result_type.

METHODS check_and_report
  IMPORTING
    business_partners TYPE business_partners
  RETURNING
    VALUE(result)     TYPE check_result.
```

### Типы параметров

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Эта секция](#типы-параметров)

#### Предпочитайте RETURNING вместо EXPORTING

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Типы параметров](#типы-параметров) > [Эта секция](#предпочитайте-returning-вместо-exporting)

```ABAP
METHODS square
  IMPORTING
    number        TYPE i
  RETURNING
    VALUE(result) TYPE i.

DATA(result) = square( 42 ).
```

Вместо излишне длинного

```ABAP
" anti-pattern
METHODS square
  IMPORTING
    number TYPE i
  EXPORTING
    result TYPE i.

square(
  EXPORTING
    number = 42
  IMPORTING
    result = DATA(result) ).
```

`RETURNING` не только делает вызов короче,
он также позволяет связывать методы в цепочку вызовов и предотвращает [при идентичном входном и выходном параметрах](#будьте-осторожны-с-идентичным-вводом-и-выводом).

#### RETURNING больших таблиц это обычно нормально

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Типы параметров](#типы-параметров) > [Эта секция](#returning-больших-таблиц-это-обычно-нормально)

Несмотря на то, что документация ABAP и руководства по производительности говорят об обратном,
мы редко сталкиваемся со случаями, когда передача большой или глубоко вложенной таблицы в VALUE параметре 
_действительно_ вызывает проблемы с производительностью.
Поэтому мы рекомендуем использовать RETURNING почти всегда:

```ABAP
METHODS get_large_table
  RETURNING
    VALUE(result) TYPE /clean/some_table_type.

METHOD get_large_table.
  result = me->large_table.
ENDMETHOD.

DATA(my_table) = get_large_table( ).
```

Если вы действительно получаете убедительные доказательства обратного (например, метрику, указывающую на плохую производительность), 
вы можете использовать более утомительный процедурный стиль.

```ABAP
" anti-pattern
METHODS get_large_table
  EXPORTING
    result TYPE /dirty/some_table_type.

METHOD get_large_table.
  result = me->large_table.
ENDMETHOD.

get_large_table( IMPORTING result = DATA(my_table) ).
```

> Этот раздел противоречит Руководству по программированию ABAP и элементам управления Code Inspector,
> которые предлагают экспортировать большие таблицы по ссылке, чтобы избежать снижения производительности. 
> Несмотря на серьезные неоднократные попытки, нам не удавалось воспроизвести дефицит производительности или памяти, 
> и мы получили уведомление об оптимизации ядра системы, которая в целом улучшает производительность RETURNING.

#### Используйте либо RETURNING, либо EXPORTING, либо CHANGING, но не комбинацию

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Типы параметров](#типы-параметров) > [Эта секция](#используйте-либо-returning-либо-exporting-либо-changing-но-не-комбинацию)

```ABAP
METHODS copy_class
  IMPORTING
    old_name      TYPE seoclsname
    new name      TYPE secolsname
  RETURNING
    VALUE(result) TYPE copy_result
  RAISING
    /clean/class_copy_failure.
```

вместо сбивающей с толку смеси

```ABAP
" anti-pattern
METHODS copy_class
  ...
  RETURNING
    VALUE(result)      TYPE vseoclass
  EXPORTING
    error_occurred     TYPE abap_bool
  CHANGING
    correction_request TYPE trkorr
    package            TYPE devclass.
```

Разные виды выходных параметров — это показатель того, что метод выполняет несколько функций. 
Это сбивает читателя с толку и излишне усложняет вызов такого метода.

Приемлемым исключением из этого правила могут быть строители (builders), 
которые используют свои входные данные при построении своих выходных данных:

```ABAP
METHODS build_tree
  CHANGING
    tokens        TYPE tokens
  RETURNING
    VALUE(result) TYPE REF TO tree.
```

Тем не менее, даже их можно сделать понятнее, приобразовав входные данные в объект:

```ABAP
METHODS build_tree
  IMPORTING
    tokens        TYPE REF TO token_stack
  RETURNING
    VALUE(result) TYPE REF TO tree.
```

#### Используйте CHANGING с осторожностью, там, где это подходит

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Типы параметров](#типы-параметров) > [Эта секция](#используйте-changing-с-осторожностью-там-где-это-подходит)

`CHANGING` следует использовать только в тех случаях, 
когда существующая локальная переменная, уже
содержащая данные, должна обновиться лишь частично:

```ABAP
METHODS update_references
  IMPORTING
    new_reference TYPE /bobf/conf_key
  CHANGING
    bo_nodes      TYPE root_nodes.

METHOD update_references.
  LOOP AT bo_nodes REFERENCE INTO DATA(bo_node).
    bo_node->reference = new_reference.
  ENDLOOP.
ENDMETHOD.
```

Не заставляйте людей, пользующихся вашими методами, вводить ненужные локальные переменные для того, чтобы заполнить `CHANGING` параметр.
Не используйте `CHANGING` параметры для заполнения ранее пустой переменной.

#### Разделите метод вместо использования булева входного параметра

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Типы параметров](#типы-параметров) > [Эта секция](#разделите-метод-вместо-использования-булева-входного-параметра)

Наличие булевых входных параметров часто является признаком того, что метод делает две вещи вместо одной.

```ABAP
" anti-pattern
METHODS update
  IMPORTING
    do_save TYPE abap_bool.
```

Кроме того, вызовы методов с одним и, обычно, безымянным логическим параметром, 
как правило, скрывают предназначение этого параметра.

```ABAP
" anti-pattern
update( abap_true ).  " what does 'true' mean? synchronous? simulate? commit?
```

Разделение метода может помочь упростить код самого метода и лучше описать различные намерения.

```ABAP
update_without_saving( ).
update_and_save( ).
```

В то же время, согласно общему мнению сообщества, совершенно нормально создать сеттер для логической переменной:

```ABAP
METHODS set_is_deleted
  IMPORTING
    new_value TYPE abap_bool.
```

> Подробнее в
> [1](http://www.beyondcode.org/articles/booleanVariables.html)
> [2](https://silkandspinach.net/2004/07/15/avoid-boolean-parameters/)
> [3](http://jlebar.com/2011/12/16/Boolean_parameters_to_API_functions_considered_harmful..html)

### Имена параметров

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Эта секция](#имена-параметров)

#### Подумайте о том, чтобы назвать RETURNING параметр RESULT

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Имена параметров](#имена-параметров) > [Эта секция](#подумайте-о-том-чтобы-назвать-returning-параметр-result)

Обычно, если имена методов подобраны правильно, то параметр `RETURNING` не нуждается в собственном имени. Его имя будет не более чем повторением имени метода или чего-то столь же очевидного.

Повторение имени атрибута может даже привести к конфликтам, которые придется разрешать добавлением `me->`.

```ABAP
" anti-pattern
METHODS get_name
  RETURNING
    VALUE(name) TYPE string.

METHOD get_name.
  name = me->name.
ENDMETHOD.
```

В этих случаях просто назовите параметр `RESULT` или `RV_RESULT` и т. п., если вы придерживаетесь венгерской нотации.

Дайте `RETURNING` параметру осмысленное имя только если неясно, что он означает, например, 
в методах, которые возвращают `me` в цепочке вызовов методов, или в методах, которые что-то создают, 
но не возвращают созданный объект, а только его ключ или что-то подобное.

### Инициализация параметров

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Эта секция](#инициализация-параметров)

#### Очистите или перезапишите EXPORTING ссылочные параметры

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Инициализация параметров](#инициализация-параметров) > [Эта секция](#очистите-или-перезапишите-exporting-ссылочные-параметры)

Ссылочные параметры относятся к существующим областям памяти, которые могут быть заполнены заранее. 
Очистите или перезапишите их, чтобы обеспечить достоверность данных:

```ABAP
METHODS square
  EXPORTING
    result TYPE i.

" clear
METHOD square.
  CLEAR result.
  " ...
ENDMETHOD.

" overwrite
METHOD square.
  result = cl_abap_math=>square( 2 ).
ENDMETHOD.
```

> Инспектор кода и Checkman указывают на переменные `EXPORTING`, которые никогда не записываются.
Используйте эти статические проверки, чтобы избежать ошибки такого рода.

##### Будьте осторожны с идентичным вводом и выводом

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Инициализация параметров](#инициализация-параметров) > [Эта секция](#будьте-осторожны-с-идентичным-вводом-и-выводом)

Как правило, рекомендуется очистить параметр в методе сразу после объявления типов и данных.
Это упрощает поиск и предотвращает случайное использование все еще содержащегося значения последующими операторами.

Однако, некоторые конфигурации параметров могут использовать одну и ту же переменную в качестве ввода и вывода.
В этом случае использование CLEAR вначале удалит входное значение до того, как его можно будет использовать, что приведет к неверным результатам.

```ABAP
" anti-pattern
DATA value TYPE i.

square_dirty(
  EXPORTING
    number = value
  IMPORTING
    result = value ).

METHOD square_dirty.
  CLEAR result.
  result = number * number.
ENDMETHOD.
```

Подумайте об изменения возвращаемого значения таких методов с `EXPORTING` на `RETURNING`. 
Кроме того, вы можете напрямую перезаписать параметр EXPORTING результатом вашего расчета без предварительного CLEAR. 
Если ни одно из этих решений не работает, попробуйте поздний `CLEAR`.

#### Не очищайте VALUE параметры

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Инициализация параметров](#инициализация-параметров) > [Эта секция](#не очищайте-value-параметры)

Параметры, которые работаю с `VALUE`, передаются как новые отдельные области памяти, пустые по определению. 
Не очищайте их снова:

```ABAP
METHODS square
  EXPORTING
    VALUE(result) TYPE i.

METHOD square.
  " no need to CLEAR result
ENDMETHOD.
```

`RETURNING` параметры всегда являются `VALUE` параметрами, поэтому вам никогда не придется их очищать:

```ABAP
METHODS square
  RETURNING
    VALUE(result) TYPE i.

METHOD square.
  " no need to CLEAR result
ENDMETHOD.
```

### Тело метода

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Эта секция](#тело-метода)

#### Делай что-то одно, делай это хорошо, делай только это

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Тело метода](#тело-метода) > [Эта секция](#делай-что-то-одно-делай-это-хорошо-делай-только-это)

Метод должен делать что-то одно и только одно.
Он должен делать это очень хорошо.

Метод, скорее всего, делает одну вещь, если

- он имеет [несколько входных параметров](#стремитесь-к-нескольким-importing-параметрам-лучше-всего-меньше-трех)
- он [не имеет булевых параметров](#разделите-метод-вместо-использования-булева-входного-параметра)
- он имеет [только один выходной параметр](#return-export-или-change-только-одного-параметра)
- он [небольшой](#сохраняйте-методы-небольшими)
- он [спускается только на один уровень абстракции](#спуститесь-на-один-уровень-абстракции)
- он [бросает один тип исключения](#бросайте-один-тип-исключения)
- вы не можете извлечь из него другие осмысленные методы
- вы не можете осмысленно сгруппировать его объявления в отдельный метод

#### Сосредоточьтесь либо на благополучном исходе либо на обработке ошибок, но не на том и другом одновременно

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Тело метода](#тело-метода) > [Эта секция](#сосредоточьтесь-либо-на-благополучном-исходе-либо-на-обработке-ошибок-но-не-на-том-и-другом-одновременно)

Помимо правила [_Делай что-то одно, делай это хорошо, делай только это_](#делай-что-то-одно-делай-это-хорошо-делай-только-это),
метод должен следовать либо по пути благополучного исхода, для которого он был создан
либо, если не может, то по пути обработки ошибок,
но, очевидно, не по обоим одновременно.

```ABAP
" anti-pattern
METHOD append_xs.
  IF input > 0.
    DATA(remainder) = input.
    WHILE remainder > 0.
      result = result && `X`.
      remainder = remainder - 1.
    ENDWHILE.
  ELSEIF input = 0.
    RAISE EXCEPTION /dirty/sorry_cant_do( ).
  ELSE.
    RAISE EXCEPTION cx_sy_illegal_argument( ).
  ENDIF.
ENDMETHOD.
```

Может быть разложено на

```ABAP
METHOD append_xs.
  validate( input ).
  DATA(remainder) = input.
  WHILE remainder > 0.
    result = result && `X`.
    remainder = remainder - 1.
  ENDWHILE.
ENDMETHOD.

METHOD validate.
  IF input = 0.
    RAISE EXCEPTION /dirty/sorry_cant_do( ).
  ELSEIF input < 0.
    RAISE EXCEPTION cx_sy_illegal_argument( ).
  ENDIF.
ENDMETHOD.
```

или, чтобы подчеркнуть часть с проверкой

```ABAP
METHOD append_xs.
  IF input > 0.
    result = append_xs_without_check( input ).
  ELSEIF input = 0.
    RAISE EXCEPTION /dirty/sorry_cant_do( ).
  ELSE.
    RAISE EXCEPTION cx_sy_illegal_argument( ).
  ENDIF.
ENDMETHOD.

METHOD append_xs_without_check.
  DATA(remainder) = input.
  WHILE remainder > 0.
    result = result && `X`.
    remainder = remainder - 1.
  ENDWHILE.
ENDMETHOD.
```

#### Спуститесь на один уровень абстракции

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Тело метода](#тело-метода) > [Эта секция](#спуститесь-на-один-уровень-абстракции)

Операторы в методе должны быть на один уровень абстракции ниже самого метода.
Соответственно, все эти операторы должны быть одного уровня абстракции.

```ABAP
METHOD create_and_publish.
  post = create_post( user_input ).
  post->publish( ).
ENDMETHOD.
```

вместо запутанных смесей низкоуровневых операций (`trim`, `to_upper`,...) и высокоуровневых (`publish`,...) например

```ABAP
" anti-pattern
METHOD create_and_publish.
  post = NEW blog_post( ).
  DATA(user_name) = trim( to_upper( sy-uname ) ).
  post->set_author( user_name ).
  post->publish( ).
ENDMETHOD.
```

Надежный способ узнать, какой уровень абстракции является правильным, заключается в следующем: 
попросите автора метода объяснить в двух словах, что делает метод, не заглядывая в код. 
Элементы, перечисленные автором, представляют собой подметоды, которые метод должен вызвать, или операторы, которые он должен выполнить.

#### Сохраняйте методы небольшими

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Тело метода](#тело-метода) > [Эта секция](#сохраняйте-методы-небольшими)

Методы должны содержать менее 20 операторов, оптимально от 3 до 5 операторов.

```ABAP
METHOD read_and_parse_version_filters.
  DATA(active_model_version) = read_random_version_under( model_guid ).
  DATA(filter_json) = read_model_version_filters( active_model_version-guid ).
  result = parse_model_version_filters( filter_json ).
ENDMETHOD.
```

Одного, следующего объявления `DATA` достаточно, чтобы показать, что метод делает гораздо больше, чем что-то одно:

```ABAP
" anti-pattern
DATA:
  class           TYPE vseoclass,
  attributes      TYPE seoo_attributes_r,
  methods         TYPE seoo_methods_r,
  events          TYPE seoo_events_r,
  types           TYPE seoo_types_r,
  aliases         TYPE seoo_aliases_r,
  implementings   TYPE seor_implementings_r,
  inheritance     TYPE vseoextend,
  friendships     TYPE seof_friendships_r,
  typepusages     TYPE seot_typepusages_r,
  clsdeferrds     TYPE seot_clsdeferrds_r,
  intdeferrds     TYPE seot_intdeferrds_r,
  attribute       TYPE vseoattrib,
  method          TYPE vseomethod,
  event           TYPE vseoevent,
  type            TYPE vseotype,
  alias           TYPE seoaliases,
  implementing    TYPE vseoimplem,
  friendship      TYPE seofriends,
  typepusage      TYPE vseotypep,
  clsdeferrd      TYPE vseocdefer,
  intdeferrd      TYPE vseoidefer,
  new_clskey_save TYPE seoclskey.
```

Конечно, бывают случаи, когда дальнейшее разбиение большого метода не имеет смысла. 
Это совершенно нормально, пока метод остается [сосредоточенным на одной вещи](#делай-что-то-одно-делай-это-хорошо-делай-только-это):

```ABAP
METHOD decide_what_to_do.
  CASE temperature.
    WHEN burning.
      result = air_conditioning.
    WHEN hot.
      result = ice_cream.
    WHEN moderate.
      result = chill.
    WHEN cold.
      result = skiing.
    WHEN freezing.
      result = hot_cocoa.
  ENDCASE.
ENDMETHOD.
```

Тем не менее, все же имеет смысл проверить, не скрывает ли такой длинный код более элегантный паттерн:

```ABAP
METHOD decide_what_to_do.
  result = VALUE #( spare_time_activities[ temperature = temperature ] OPTIONAL ).
ENDMETHOD.
```

> Нарезка методов до минимума может отрицательно сказаться на производительности, поскольку приводит к увеличению количества вызовов методов. 
> Раздел [_Помните о производительности_](#помните-о-производительности) содержит советы по поиску баланса между Чистым кодом и оптимальной производительностью.

### Поток управления

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) >  [Эта секция](#поток-управления)

#### Быстрый провал

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Поток управления](#поток-управления) > [Эта секция](#быстрый-провал)

Выполняйте проверку и прекращайте работу в случае неудачи как можно раньше:

```ABAP
METHOD do_something.
  IF input IS INITIAL.
    RAISE EXCEPTION cx_sy_illegal_argument( ).
  ENDIF.
  DATA(massive_object) = build_expensive_object_from( input ).
  result = massive_object->do_some_fancy_calculation( ).
ENDMETHOD.
```

Более поздние проверки труднее увидеть и понять, и к этому моменту вы можете потратить ресурсы впустую.

```ABAP
" anti-pattern
METHOD do_something.
  DATA(massive_object) = build_expensive_object_from( input ).
  IF massive_object IS NOT BOUND. " happens if input is initial
    RAISE EXCEPTION cx_sy_illegal_argument( ).
  ENDIF.
  result = massive_object->do_some_fancy_calculation( ).
ENDMETHOD.
```

#### CHECK против RETURN

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Поток управления](#поток-управления) > [Эта секция](#check-против-return)

Нет единого мнения о том, следует ли использовать CHECK или RETURN для выхода из метода, 
когда ввод не соответствует ожидаемому.

Хотя `CHECK` определенно обеспечивает более короткий синтаксис,

```ABAP
METHOD read_customizing.
  CHECK keys IS NOT INITIAL.
  " do whatever needs doing
ENDMETHOD.
```

имя оператора не говорит о том, что произойдет, если условие не выполнится. 
Поэтому, длинная форма в целом более понятна:

```ABAP
METHOD read_customizing.
  IF keys IS INITIAL.
    RETURN.
  ENDIF.
  " do whatever needs doing
ENDMETHOD.
```

Вы можете полностью избежать этого вопроса, 
изменив проверку и внедрив поток управления с одним возвратом.

```ABAP
METHOD read_customizing.
  IF keys IS NOT INITIAL.
    " do whatever needs doing
  ENDIF.
ENDMETHOD.
```

В любом случае, подумайте, действительно ли отсутствие возвращаемого результата является правильным поведением. 
Методы должны предоставлять осмысленный результат, т.е. заполненный возвращаемый параметр или исключение. 
Во многих случаях отсутствие возвращенного результата эквивалентно возврату null, чего следует избегать.

> Раздел [_Выход из процедур_ в Руководстве по программированию на ABAP](https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-US/index.htm?file=abenexit_procedure_guidl.htm)
> в этом случае рекомендует использовать `CHECK`.
> Обсуждение в сообществе показывает, что этот оператор настолько неясен,
> что многие люди не поймут поведение программы.

#### Избегайте CHECK в других местах

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Методы](#методы) > [Поток управления](#поток-управления) > [Эта секция](#избегайте-check-в-других-местах)

Не используйте `CHECK` вне раздела инициализации метода.
Оператор ведет себя по-разному в разных позициях и может привести к неясным, неожиданным эффектам.

Например,
[`CHECK` в `LOOP` завершает текущую итерацию и переходит к следующей](https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abapcheck_loop.htm),
а не завершает метод или, по крайней мере, цикл, как можно было бы ошибочно ожидать.
Вместо этого лучше использовать оператор `IF` в сочетании с `CONTINUE`, так как `CONTINUE` можно использовать только в циклах.

> Основано на разделе [_Выход из процедур_](https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-US/index.htm?file=abenexit_procedure_guidl.htm) в Руководстве по программированию на ABAP.
> Обратите внимание, что это противоречит [справке о ключевом слове `CHECK` в циклах](https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abapcheck_loop.htm).

## Обработка ошибок

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Эта секция](#обработка-ошибок)

### Сообщения

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Обработка ошибок](#обработка-ошибок) > [Эта секция](#сообщения)

#### Сделайте сообщения легко находимыми

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Обработка ошибок](#обработка-ошибок) > [Сообщения](#сообщения) > [Эта секция](#сделайте-сообщения-легко-находимыми)

Чтобы упростить поиск сообщений с помощью поиска по месту использования из транзакции SE91, используйте следующий шаблон:

```ABAP
MESSAGE e001(ad) INTO DATA(message).
```

Если переменная `message` не нужна, добавьте прагму `##NEEDED`:

```ABAP
MESSAGE e001(ad) INTO DATA(message) ##NEEDED.
```

Избегайте следующего:

```ABAP
" anti-pattern
IF 1 = 2. MESSAGE e001(ad). ENDIF.
```

Это анти-паттерн, поскольку:
- Он содержит недостижимый код.
- Он проверяет условие, которое никогда не может быть истинным для равенства.

### Коды возврата

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Обработка ошибок](#обработка-ошибок) > [Эта секция](#коды-возврата)

#### Предпочитайте исключения кодам возврата

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Обработка ошибок](#обработка-ошибок) > [Коды возврата](#коды-возврата) > [Эта секция](#предпочитайте-исключения-кодам-возврата)

```ABAP
METHOD try_this_and_that.
  RAISE EXCEPTION NEW cx_failed( ).
ENDMETHOD.
```

вместо

```ABAP
" anti-pattern
METHOD try_this_and_that.
  error_occurred = abap_true.
ENDMETHOD.
```

Исключения имеют множество преимуществ перед кодами возврата:

- Исключения сохраняют сигнатуры ваших методов чистыми:
вы можете вернуть результат метода как параметр `RETURNING` и по-прежнему генерировать исключения.
Коды возврата загрязняют ваши подписи дополнительными параметрами для обработки ошибок.

- Вызывающей программе не нужно немедленно реагировать на исключения. 
Можно просто придерживаться правильных вариантов использования своего кода. 
Обработчик исключений CATCH может находиться в самом конце своего метода или полностью вне его.

- Исключения могут предоставлять сведения об ошибках, хранящиеся в их атрибутах, с помощью методов. 
Коды возврата заставляют вас самостоятельно придумывать другое решение (например, возвращать журнал).

- Окружение напоминает вызывающей программе о синтаксических ошибках для обработки исключений. 
Коды возврата могут быть случайно проигнорированы, и никто этого не заметит.

#### Не позволяйте неудачам проскользнуть

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Обработка ошибок](#обработка-ошибок) > [Коды возврата](#коды-возврата) > [Эта секция](#не-позволяйте-неудачам-проскользнуть)

Если вам все же приходится использовать коды возврата, например, потому что вы вызываете функции и старый код, 
который не находится под вашим контролем, убедитесь, что вы не допускаете ошибок.

```ABAP
DATA:
  current_date TYPE string,
  response     TYPE bapiret2.

CALL FUNCTION 'BAPI_GET_CURRENT_DATE'
  IMPORTING
    current_date = current_date
  CHANGING
    response     = response.

IF response-type = 'E'.
  RAISE EXCEPTION NEW /clean/some_error( ).
ENDIF.
```

### Исключения

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Обработка ошибок](#обработка-ошибок) > [Эта секция](#исключения)

#### Исключения для ошибок, а не для обычных случаев

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Обработка ошибок](#обработка-ошибок) > [Исключения](#исключения) > [Эта секция](#исключения-для-ошибок-а-не-для-обычных-случаев)

```ABAP
" anti-pattern
METHODS entry_exists_in_db
  IMPORTING
    key TYPE char10
  RAISING
    cx_not_found_exception.
```

Если что-то является обычным, допустимым случаем, оно должно обрабатываться с помощью обычных параметров возвращающих результат.

```ABAP
METHODS entry_exists_in_db
  IMPORTING
    key           TYPE char10
  RETURNING
    VALUE(result) TYPE abap_bool.
```

Исключения должны применяться только для случаев, которые вы не ожидаете и которые отражают ошибочные ситуации.

```ABAP
METHODS assert_user_input_is_valid
  IMPORTING
    user_input TYPE string
  RAISING
    cx_bad_user_input.
```

Неправильное использование исключений вводит читателя в заблуждение, заставляя его думать, что что-то пошло не так, хотя на самом деле все в порядке.
Исключения намного медленнее, чем обычный код, потому что их нужно создавать и они часто собирают много контекстной информации.

#### Используйте исключения на основе классов

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Обработка ошибок](#обработка-ошибок) > [Исключения](#исключения) > [Эта секция](#используйте-исключения-на-основе-классов)

```ABAP
TRY.
    get_component_types( ).
  CATCH cx_has_deep_components_error.
ENDTRY.
```

Устаревшие исключения, основанные не на классах, имеют ту же функциональность, что и коды возврата, и больше не следует их использовать.

```ABAP
" anti-pattern
get_component_types(
  EXCEPTIONS
    has_deep_components = 1
    OTHERS              = 2 ).
```

### Бросание

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Обработка ошибок](#обработка-ошибок) > [Эта секция](#бросание)

#### Используйте собственные суперклассы

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Обработка ошибок](#обработка-ошибок) > [Бросание](#бросание) > [Эта секция](#используйте-собственные-суперклассы)

```ABAP
CLASS cx_fra_static_check DEFINITION ABSTRACT INHERITING FROM cx_static_check.
CLASS cx_fra_no_check DEFINITION ABSTRACT INHERITING FROM cx_no_check.
```

Рассмотрите возможность создания абстрактных суперклассов для каждого типа исключений вашего приложения 
вместо прямого наследования от базовых классов. 
Это позволит вам поймать (catch) все ваши исключения. 
Даст возможность добавить общие функции ко всем исключениям, например специальную обработку текста. 
Делайте такие классы `ABSTRACT`ными, чтобы случайно не использовать их напрямую.

#### Бросайте один тип исключения

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Обработка ошибок](#обработка-ошибок) > [Бросание](#бросание) > [Эта секция](#бросайте-один-тип-исключения)

```ABAP
METHODS generate
  RAISING
    cx_generation_error.
```

В подавляющем большинстве случаев создание нескольких типов исключений бесполезно. 
Как правило, вызывающая программа не имеет ни желания, ни возможности различать ошибочные ситуации. 
Поэтому она будет относиться к ним в целом одинаково, а если так, то зачем их вообще различать?

```ABAP
" anti-pattern
METHODS generate
  RAISING
    cx_abap_generation
    cx_hdbr_access_error
    cx_model_read_error.
```

Лучшим решением для распознавания различных ситуаций с ошибками является 
использование одного типа исключения, но с добавлением подклассов, 
которые позволяют (но не требуют) реагировать на отдельные ситуации с ошибками, 
как описано в разделе [Используйте подклассы, чтобы вызывающие могли различать ошибочные ситуации](#используйте-подклассы-чтобы-вызывающие-могли-различать-ошибочные-ситуации).

#### Используйте подклассы, чтобы вызывающие могли различать ошибочные ситуации

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Обработка ошибок](#обработка-ошибок) > [Бросание](#бросание) > [Эта секция](#используйте-подклассы-чтобы-вызывающие-могли-различать-ошибочные-ситуации)

```ABAP
CLASS cx_bad_generation_variable DEFINITION INHERITING FROM cx_generation_error.
CLASS cx_bad_code_composer_template DEFINITION INHERITING FROM cx_generation_error.

METHODS generate RAISING cx_generation_error.

TRY.
    generator->generate( ).
  CATCH cx_bad_generation_variable.
    log_failure( ).
  CATCH cx_bad_code_composer_template INTO DATA(bad_template_exception).
    show_error_to_user( bad_template_exception ).
  CATCH cx_generation_error INTO DATA(other_exception).
    RAISE EXCEPTION NEW cx_application_error( previous =  other_exception ).
ENDTRY.
```

Если существует много разных ошибочных ситуаций, используйте коды ошибок:

```ABAP
CLASS cx_generation_error DEFINITION ...
  PUBLIC SECTION.
    TYPES error_code_type TYPE i.
    CONSTANTS:
      BEGIN OF error_code_enum,
        bad_generation_variable    TYPE error_code_type VALUE 1,
        bad_code_composer_template TYPE error_code_type VALUE 2,
        ...
      END OF error_code_enum.
    DATA error_code TYPE error_code_type.

TRY.
    generator->generate( ).
  CATCH cx_generation_error INTO DATA(exception).
    CASE exception->error_code.
      WHEN cx_generation_error=>error_code_enum-bad_generation_variable.
      WHEN cx_generation_error=>error_code_enum-bad_code_composer_variable.
      ...
    ENDCASE.
ENDTRY.
```

#### Бросайте CX_STATIC_CHECK для управляемых исключений

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Обработка ошибок](#обработка-ошибок) > [Бросание](#бросание) > [Эта секция](#бросайте-cx_static_check-для-управляемых-исключений)

Если исключительная ситуация может быть ожидаема и разумно обработана программой-получателем, 
сгенерируйте проверенное исключение, унаследованное от `CX_STATIC_CHECK`: не удалось выполнить проверку пользовательского ввода, 
отсутствует ресурс, для которого существуют резервные копии, и т. д.

```ABAP
CLASS cx_file_not_found DEFINITION INHERITING FROM cx_static_check.

METHODS read_file
  IMPORTING
    file_name_enterd_by_user TYPE string
  RAISING
    cx_file_not_found.
```

Этот тип исключения _должен_ быть указан в сигнатурах методов и 
_должен_ быть перехвачен или перенаправлен, чтобы избежать синтаксических ошибок. 
Таким образом, потребитель гарантированно увидет его, не удивится неожиданному исключению 
и позаботится о том, чтобы отреагировать на ошибочную ситуацию.

> Это соответствует [Руководству по программированию на ABAP](https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-US/abenexception_category_guidl.htm)
> но противоречит [Robert C. Martin's _Clean Code_],
> который рекомендует предпочесть непроверяемые исключения;  
> Раздел [Исключения](sub-sections/Exceptions.md) объясняет, почему.

#### Бросайте CX_NO_CHECK для обычно безнадежных ситуаций

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Обработка ошибок](#обработка-ошибок) > [Бросание](#бросание) > [Эта секция](#бросайте-cx_no_check-для-обычно-безнадежных-ситуаций)

Если исключение настолько серьезное, что получатель вряд ли восстановится после него, используйте `CX_NO_CHECK`: 
сбой при чтении обязательного ресурса, невозможность разрешения запрошенной зависимости и т. д.

```ABAP
CLASS cx_out_of_memory DEFINITION INHERITING FROM cx_no_check.

METHODS create_guid
  RETURNING
    VALUE(result) TYPE /bobf/conf_key.
```

`CX_NO_CHECK` _не может_ быть объявлен в сигнатурах методов,
и поэтому всегда является неприятным сюрпризом для потребителя. 
В ситуациях, которые нельзя исправить, это нормально, потому что потребитель все равно не может отреагировать на них полезным образом.

Однако, в некоторых случаях потребителю на самом деле необходимо 
идентифицировать этот тип отказа и отреагировать на него соответствующим образом. 
Например, диспетчер зависимостей может сгенерировать исключение CX_NO_CHECK, 
потому что обычный код приложения, вероятно, все равно не может продолжить работу.
В то же время тестовая программа, которая пытается создавать экземпляры чего-либо, 
просто чтобы проверить, что они работают, должна сообщить об ошибке в виде красной записи в списке. 
Этот сервис должен иметь возможность перехватывать и игнорировать исключение, а не создавать дамп памяти.

#### Подумайте об использовании CX_DYNAMIC_CHECK для исключений, которых можно избежать

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Обработка ошибок](#обработка-ошибок) > [Бросание](#бросание) > [Эта секция](#подумайте-об-использовании-cx_dynamic_check-для-исключений-которых-можно-избежать)

Случаи использования `CX_DYNAMIC_CHECK` встречаются редко, и в целом мы рекомендуем использовать другие типы исключений. 
Однако, вы можете использовать этот тип исключения вместо `CX_STATIC_CHECK`, 
если вызывающая программа полностью контролирует возникающие ошибки.

```ABAP
DATA value TYPE decfloat.
value = '7.13'.
cl_abap_math=>get_db_length_decs(
  EXPORTING
    in     = value
  IMPORTING
    length = DATA(length) ).
```

Например, посмотрите на метод `get_db_length_decs` класса `cl_abap_math`, 
который сообщает вам количество цифр и десятичных разрядов в десятичном числе с плавающей запятой. 
Этот метод вызывает динамическое исключение `cx_parameter_invalid_type`, 
если входной параметр не соответствует десятичному числу с плавающей запятой. 
Этот метод обычно вызывается для статистически типизированной переменной, поэтому разработчик знает, 
когда может возникнуть это исключение. 
В этом случае динамическое исключение позволит вызывающей стороне опустить избыточное предложение `CATCH`.

#### Дамп для полностью неисправимых ситуаций

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Обработка ошибок](#обработка-ошибок) > [Бросание](#бросание) > [Эта секция](#дамп-для-полностью-неисправимых-ситуаций)

Если ситуация настолько серьезна, что вы полностью уверены, что получатель вряд ли сможет восстановиться после нее, 
или это явно указывает на программную ошибку, вместо создания исключения создайте дамп: 
сбой при захвате памяти, сбой при чтении индекса в таблице, которая должна быть заполнена, т. д.

```ABAP
RAISE SHORTDUMP TYPE cx_sy_create_object_error.  " >= NW 7.53
MESSAGE x666(general).                           " < NW 7.53
```
Такое поведение не позволит какому-либо потребителю сделать что-либо полезное впоследствии.
Поэтому, используйте это только если вы уверены в этом.

#### Предпочитайте RAISE EXCEPTION NEW вместо RAISE EXCEPTION TYPE

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Обработка ошибок](#обработка-ошибок) > [Бросание](#бросание) > [Эта секция](#предпочитайте-raise-exception-new-вместо-raise-exception-type)

Примечание. Доступно начиная с NW 7.52.

```ABAP
RAISE EXCEPTION NEW cx_generation_error( previous = exception ).
```

в целом короче, чем излишне длиннее

```ABAP
RAISE EXCEPTION TYPE cx_generation_error
  EXPORTING
    previous = exception.
```

Однако, если вы часто используете опцию `MESSAGE`, рекомендуется придерживаться варианта с `TYPE`:

```ABAP
RAISE EXCEPTION TYPE cx_generation_error
  MESSAGE e136(messages)
  EXPORTING
    previous = exception.
```

### Отлавливание

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Обработка ошибок](#обработка-ошибок) > [Эта секция](#отлавливание)

#### Оберните внешние исключения вместо того, чтобы позволять им вторгаться в ваш код

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Обработка ошибок](#обработка-ошибок) > [Отлавливание](#отлавливание) > [Эта секция](#оберните-внешние-исключения-вместо-того-чтобы-позволять-им-вторгаться-в-ваш-код)

```ABAP
METHODS generate RAISING cx_generation_failure.

METHOD generate.
  TRY.
      generator->generate( ).
    CATCH cx_amdp_generation_failure INTO DATA(exception).
      RAISE EXCEPTION NEW cx_generation_failure( previous = exception ).
  ENDTRY.
ENDMETHOD.
```

[Закон Деметры](https://en.wikipedia.org/wiki/Law_of_Demeter) рекомендует разъединять вещи.
Передача исключений из других компонентов нарушает этот принцип. 
Обеспечьте себе независимость от чужого кода, перехватывая эти исключения и заключая их в свой собственный тип исключения.

```ABAP
" anti-pattern
METHODS generate RAISING cx_sy_gateway_failure.

METHOD generate.
  generator->generate( ).
ENDMETHOD.
```

## Комментарии

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Эта секция](#комментарии)

### Выражайте себя в коде, а не в комментариях

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Комментарии](#комментарии) > [Эта секция](#выражайте-себя-в-коде-а-не-в-комментариях)

```ABAP
METHOD correct_day_to_last_in_month.
  WHILE is_invalid( date ).
    reduce_day_by_one( CHANGING date = date ).
  ENDWHILE.
ENDMETHOD.

METHOD is_invalid.
  DATA zero_if_invalid TYPE i.
  zero_if_invalid = date.
  result = xsdbool( zero_if_invalid = 0 ).
ENDMETHOD.

METHOD reduce_day_by_one.
  date+6(2) = date+6(2) - 1.
ENDMETHOD.
```

вместо

```ABAP
" anti-pattern
" correct e.g. 29.02. in non-leap years as well as result of a date calculation would be
" something like e.g. the 31.06. that example has to be corrected to 30.06.
METHOD fix_day_overflow.
  DO 3 TIMES.
    " 31 - 28 = 3 => this correction is required not more than 3 times
    lv_dummy = cv_date.
    " lv_dummy is 0 if the date value is a not existing date - ABAP specific implementation
    IF ( lv_dummy EQ 0 ).
      cv_date+6(2) = cv_date+6(2) - 1. " subtract 1 day from the given date
    ELSE.
      " date exists => no correction required
      EXIT.
    ENDIF.
  ENDDO.
ENDMETHOD.
```

Чистый код не запрещает вам комментировать свой код, а скорее побуждает вас использовать лучшие инструменты 
и прибегать к комментариям только тогда, когда вы не получаете желаемого результата другими способами.

> Этот пример был оспорен с точки зрения производительности. Были утверждения, 
> что сокращение методов слишком сильно ухудшает производительность. 
> Примерные измерения показывают, что код после рефакторинга работает в 2,13 раза медленнее исходного, грязного варианта. 
> Чистому варианту требуется 9,6 мкс, чтобы исправить ввод `31-02-2018`, грязному варианту — всего 4,5 мкс. 
> Это может вызвать проблемы, если метод будет запускаться очень часто в высокопроизводительном приложении. 
> Для обычной проверки пользовательского ввода это должно быть приемлемо. 
> Обратитесь к разделу [Помните о производительности](#помните-о-производительности), если вы испытываете проблемы с производительностью сдедуя Чистому коду.

### Комментарии — не оправдание плохих имен

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Комментарии](#комментарии) > [Эта секция](#комментарии--не-оправдание-плохих-имен)

```ABAP
DATA(input_has_entries) = has_entries( input ).
```

Используйте более подходящие имена вместо того, чтобы объяснять, что вы на самом деле имеете в виду или почему вы выбрали неподходящее имя.

```ABAP
" anti-pattern
" checks whether the table input contains entries
DATA(result) = check_table( input ).
```

### Используйте методы вместо комментариев для сегментации кода

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Комментарии](#комментарии) > [Эта секция](#используйте-методы-вместо-комментариев-для-сегментации-кода)

```ABAP
DATA(statement) = build_statement( ).
DATA(data) = execute_statement( statement ).
```

Это не только делает назначение кода, структуру и зависимости более понятными, но также позволяет избежать последующих ошибок, 
когда временные переменные не сбрасываются должным образом между разделами.

```ABAP
" anti-pattern
" -----------------
" Build statement
" -----------------
DATA statement TYPE string.
statement = |SELECT * FROM d_document_roots|.

" -----------------
" Execute statement
" -----------------
DATA(result_set) = adbc->execute_sql_query( statement ).
result_set->next_package( IMPORTING data = data ).
```

### Пишите комментарии, чтобы объяснить, почему, а не что

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Комментарии](#комментарии) > [Эта секция](#пишите-комментарии-чтобы-объяснить-почему-а-не-что)

```ABAP
" can't fail, existence of >= 1 row asserted above
DATA(first_line) = table[ 1 ].
```

Никому не нужно повторение кода на естественном языке

```ABAP
" anti-pattern
" select alert root from database by key
SELECT * FROM d_alert_root WHERE key = key.
```

### Описание проекта должно быть в проектной документации, а не в коде

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Комментарии](#комментарии) > [Эта секция](#описание-проекта-должно-быть-в-проектной-документации-а-не-в-коде)

```ABAP
" anti-pattern
" This class serves a double purpose. First, it does one thing. Then, it does another thing.
" It does so by executing a lot of code that is distributed over the local helper classes.
" To understand what's going on, let us at first ponder the nature of the universe as such.
" Have a look at this and that to get the details.
```

Этого никто не читает, честное слово. 
Если для понимания вашего кода требуется учебник, это может указывать на то, что в вашем коде есть серьезные проблемы проектирования, 
которые вам следует решать другими способами. Если ваш код действительно нуждается в объяснении помимо одной строки комментария, 
что приемлемо, мы предлагаем оставлять ссылку на проектную документацию.

### Комментируйте используя ", а не *

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Комментарии](#комментарии) > [Эта секция](#комментируйте-используя--а-не-)

Комментарии в двойных кавычках форматируются при выполнении структурной печати и получают отступ в соответствии с инструкциями, к которым они относятся.

```ABAP
METHOD do_it.
  IF input IS NOT INITIAL.
    " delegate pattern
    output = calculate_result( input ).
  ENDIF.
ENDMETHOD.
```

Комментарии со звездочкой, как правило, имеют странные отступы.

```ABAP
" anti-pattern
METHOD do_it.
  IF input IS NOT INITIAL.
* delegate pattern
    output = calculate_result( input ).
  ENDIF.
ENDMETHOD.
```

### Размещайте комментарии перед утверждением, к которому они относятся

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Комментарии](#комментарии) > [Эта секция](#размещайте-комментарии-перед-утверждением-к-которому-они-относятся)

```ABAP
" delegate pattern
output = calculate_result( input ).
```

Понятнее, чем

```ABAP
" anti-pattern
output = calculate_result( input ).
" delegate pattern
```

И менее инвазивен, чем

```ABAP
output = calculate_result( input ).  " delegate pattern
```

### Удаляйте код вместо того, чтобы комментировать его

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Комментарии](#комментарии) > [Эта секция](#удаляйте-код-вместо-того-чтобы-комментировать-его)

```ABAP
" anti-pattern
* output = calculate_result( input ).
```

Если вы найдете что-то похожее, удалите это.
Этот закомментированный код явно не нужен, потому что ваше приложение работает и без него и все тесты проходят. 
При необходимости, удаленный код можно воспроизвести из истории версий. 
Если вам нужно сохранить фрагмент кода навсегда, скопируйте его в файл или объект `$TMP` или `HOME`.

### Используйте FIXME, TODO, и XXX и добавьте свой ID

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Комментарии](#комментарии) > [Эта секция](#используйте-fixme-todo-и-xxx-и-добавьте-свой-id)

```ABAP
METHOD do_something.
  " XXX FH delete this method - it does nothing
ENDMETHOD.
```

- `FIXME` указывает на ошибки, которые слишком малы или слишком велики для внутренних инцидентов.
- `TODO` это места, где вы хотите что-то доделать в ближайшем (!) будущем.
- `XXX` отмечает код, который работает, но может быть улучшен

Когда вы добавляете такой комментарий, добавьте свой ник, инициалы или пользователя, чтобы ваши коллеги-разработчики могли связаться с вами
и задать вопросы, если комментарий им будет неясен.

### Не добавляйте сигнатуру метода и комментарии в конце

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Комментарии](#комментарии) > [Эта секция](#не-добавляйте-сигнатуру-метода-и-комментарии-в-конце)

Комментарии к сигнатуре метода никому не нужны.

```ABAP
" anti-pattern
* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Static Public Method CALIBRATION_KPIS=>CALCULATE_KPI
* +-------------------------------------------------------------------------------------------------+
* | [--->] STRATEGY_ID                 TYPE        STRATEGY_ID
* | [--->] THRESHOLD                   TYPE        STRATEGY_THRESHOLD
* | [--->] DETECTION_OBJECT_SCORE      TYPE        T_HIT_RESULT
* | [<---] KPI                         TYPE        T_SIMULATED_KPI
* +--------------------------------------------------------------------------------------</SIGNATURE>
```

Десятилетия назад, когда вы не могли посмотреть сигнатуру метода при проверке его кода или при работе с распечатками, 
состоящими из десятков страниц, эти комментарии могли иметь смысл. 
Но все современные ABAP IDE (SE24, SE80, ADT) легко показывают сигнатуру метода, 
так что эти комментарии стали не более чем шумом.

> В редакторе на основе формуляров SE24/SE80, нажмите кнопку _Сигнатура_.
> В ABAP Development Tools, отметьте название метода и нажмите F2
> или добавьте view _ABAP Element Info_ в свою перспективу.

Точно так же комментарии после закрывающих ключевых слов тоже излишни. 
Эти комментарии могли быть полезны несколько десятилетий назад, когда программы и функции, 
а также вложенные в них `IF`ы cостояли из сотен строк кода. 
Но наш современный стиль написания кода создает достаточно короткие методы, 
чтобы было легко увидеть к какому открывающему оператору относится `ENDIF` или `ENDMETHOD`:

```ABAP
" anti-pattern
METHOD get_kpi_calc.
  IF has_entries = abap_false.
    result = 42.
  ENDIF.  " IF has_entries = abap_false
ENDMETHOD.   " get_kpi_calc
```

### Не дублируйте тексты сообщений в комментариях

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Комментарии](#комментарии) > [Эта секция](#не-дублируйте-тексты-сообщений-в-комментариях)

```ABAP
" anti-pattern
" alert category not filled
MESSAGE e003 INTO dummy.
```

Сообщения изменяются независимо от вашего кода, 
и никому в голову не придет адаптировать комментарий, 
поэтому он быстро устареет и начнет вводить 
в заблуждение незаметно для всех.

Современные IDE предоставляют простые способы просмотра текста сообщения, 
например, в ABAP Development Tools для этого можно отметить идентификатор сообщения и нажать Shift+F2.

Если вы хотите сделать это более явно, 
можно вынести сообщение в отдельный метод.

```ABAP
METHOD create_alert_not_found_message.
  MESSAGE e003 INTO dummy.
ENDMETHOD.
```

### ABAP Doc только для публичных APIs

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Комментарии](#комментарии) > [Эта секция](#abap-doc-только-для-публичных-apis)

Пишите ABAP Doc только для документирования общедоступных API, 
т.е. API, предназначенных для разработчиков из других команд или приложений. 
Не пишите ABAP Doc для внутреннего использования.

ABAP Doc страдает теми же недостатками, что и все комментарии, 
то есть он быстро устаревает, а затем вводит в заблуждение. 
Поэтому, вы должны использовать его только там, где это имеет смысл, 
а не заставлять писать ABAP Doc всегда и везде.

> Подробнее в _Chapter 4: Good Comments: Javadocs in Public APIs_ and _Chapter 4: Bad Comments:
> Javadocs in Nonpublic Code_ [Robert C. Martin's _Clean Code_].

### Предпочитайте прагмы псевдокомментариям

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Комментарии](#комментарии) > [Эта секция](#предпочитайте-прагмы-псевдокомментариям)

Предпочитайте прагмы псевдокомментариям, чтобы подавить нерелевантные предупреждения и ошибки, выявленные ATC. 
Псевдокомментарии в основном устарели и были заменены прагмами.

```ABAP
" pattern
MESSAGE e001(ad) INTO DATA(message) ##NEEDED.

" anti-pattern
MESSAGE e001(ad) INTO DATA(message). "#EC NEEDED
```

Используйте программу `ABAP_SLIN_PRAGMAS` или таблицу `SLIN_DESC`, 
чтобы найти соответствие между устаревшими псевдокомментариями и прагмами, которые их заменили.

## Форматирование

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Эта секция](#форматирование)

Приведенные ниже предложения [оптимизированы для чтения, а не для написания кода](#оптимизируйте-код-для-чтения-а-не-для-написания). 
Поскольку структурная печать ABAP их не охватывает, некоторые из них требуют дополнительной ручной работы по переформатированию операторов 
при изменении длины имени и т. п. Если вы хотите избежать этого, подумайте о том, чтобы не использовать такие правила, как 
[Выравнивайте присвоения для одного и того же объекта, но не для разных](#выравнивайте-присвоения-для-одного-и-того-же-объекта-но-не-для-разных).

### Будьте последовательны

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#будьте-последовательны)

Форматируйте весь код в проекте одинаково. 
Убедитесь, что все в команде используют один и тот же стиль форматирования.

При редактировании стороннего кода придерживайтесь стиля форматирования, используемого на этом проекте, 
а не своего личного.

Если вы со временем меняете правила форматирования, 
используйте [лучшие практики рефакторинга](#как-рефакторить-устаревший-код) для обновления кода.

### Оптимизируйте код для чтения, а не для написания

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#оптимизируйте-код-для-чтения-а-не-для-написания)

Разработчики проводят большую часть своего времени за _чтением_ кода. 
На самом деле _написание_ кода занимает гораздо меньшую часть рабочего времени.

Следовательно, вы должны оптимизировать форматирование кода для чтения и отладки, а не для записи.

Например, предпочитайте это 

```ABAP
DATA:
  a TYPE b,
  c TYPE d,
  e TYPE f.
```

такому хаку,

```ABAP
" anti-pattern
DATA:
  a TYPE b
  ,c TYPE d
  ,e TYPE f.
```

### Используйте структурную печать перед активацией

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#используйте-структурную-печать-перед-активацией)

Используйте структурную печать — Shift+F1 в SE80, SE24 и ADT перед активацией объекта.

Если вы изменяете большую, необработанную, устаревшую кодовую базу, 
вы можете применить структурную печать только к выбранным строкам, 
чтобы избежать обширных списков изменений и транспортных зависимостей. 
Подумайте о применении структурной печати для всего объекта разработки 
используя отдельный транспортный запрос или ноту.

> Подробнее в _Chapter 5: Formatting: Team Rules_ [Robert C. Martin's _Clean Code_].

### Используйте настройки структурной печати вашей команды

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#используйте-настройки-структурной-печати-вашей-команды)

Всегда используйте настройки вашей команды.
Укажите их в
_Меню_ > _Утилиты_ > _Параметры настройки ..._ > _ABAP-редак._ > _Структурная печать_.

Установите _Отступ_ и _Преобразование простых/строчных букв_ > _Ключ. слово прописное_
как общепринятый в вашей команде.

> Раздел [Верхний регистр против нижнего](sub-sections/UpperVsLowerCase.md) объясняет 
> почему мы не даем четких рекомендаций по использованию заглавных букв в ключевых словах.
>
> Подробнее в _Chapter 5: Formatting: Team Rules_ [Robert C. Martin's _Clean Code_].

### Не более одного оператора в строке

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#не-более-одного-оператора-в-строке)

```ABAP
DATA do_this TYPE i.
do_this = input + 3.
```

Даже если что-то введет вас в заблуждение и заставить ошибочно полагать, что это читабельно:

```ABAP
" anti-pattern
DATA do_this TYPE i. do_this = input + 3.
```

### Придерживайтесь разумной длины строки

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#придерживайтесь-разумной-длины-строки)

Придерживайтесь максимальной длины строки в 120 символов.

Человеческому глазу удобнее читать текст, если строки не слишком широкие — 
спросите у своего любимого UI-дизайнера или исследователя движений глаз. 
Вы тоже сможете оценить более компактный код при отладке или сравнении двух параллельных источников.

Ограничение в 80 или даже 72 символа, существовавшее в старых тарминалах, 
является слишком строгим. Часто рекомендуется длина в 100 символов, и это приемлемый выбор, 
но кажется, что ограничение в 120 символов выглядит немного лучше для ABAP, возможно, из-за общей многословности языка.

> Напоминаем, что в ADT вы можете установить ограничение до 120 символов,
> после чего это при просмотре кода будет отображаться вертикальная линия. 
> Вы можете настроить это в _Menu_ > _Window_ > _Preferences_ > _General_ > _Editors_ > _Text Editors_.

### Уплотните ваш код

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#уплотните-ваш-код)

```ABAP
DATA(result) = calculate( items ).
```

вместо добавления ненужных пробелов

```ABAP
" anti-pattern
DATA(result)        =      calculate(    items =   items )   .
```

### Добавьте только одну пустую строку для разделения разных вещей, не более

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#добавьте-только-одну-пустую-строку-для-разделения-разных-вещей-не-более)

```ABAP
DATA(result) = do_something( ).

DATA(else) = calculate_this( result ).
```

чтобы подчеркнуть, что эти два утверждения делают разные вещи. Однако нет причин для

```ABAP
" anti-pattern
DATA(result) = do_something( ).



DATA(else) = calculate_this( result ).
```

Желание добавить пустые строки может быть индикатором того, что ваш метод не следует рекомендации 
[Делай что-то одно, делай это хорошо, делай только это](#делай-что-то-одно-делай-это-хорошо-делай-только-это).

### Не злоупотребляйте разделением пустыми строками

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#не-злоупотребляйте-разделением-пустыми-строками)

```ABAP
METHOD do_something.
  do_this( ).
  then_that( ).
ENDMETHOD.
```

Нет причин для того, чтобы разрывать ваш код на части пустыми строками 

```ABAP
" anti-pattern
METHOD do_something.

  do_this( ).

  then_that( ).

ENDMETHOD.
```

Пустые строки имеют смысл только в том случае, если у вас есть операторы, занимающие несколько строк.

```ABAP
METHOD do_something.

  do_this( ).

  then_that(
    EXPORTING
      variable = 'A'
    IMPORTING
      result   = result ).

ENDMETHOD.
```

### Выравнивайте присвоения для одного и того же объекта, но не для разных

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#выравнивайте-присвоения-для-одного-и-того-же-объекта-но-не-для-разных)

Чтобы подчеркнуть, что эти вещи каким-то образом связаны друг с другом

```ABAP
structure-type = 'A'.
structure-id   = '4711'.
```

или еще лучше

```ABAP
structure = VALUE #( type = 'A'
                     id   = '4711' ).
```

Но, если это не связанные вещи, оставьте такую форму записи:

```ABAP
customizing_reader = fra_cust_obj_model_reader=>s_get_instance( ).
hdb_access = fra_hdbr_access=>s_get_instance( ).
```

> Подробнее в _Chapter 5: Formatting: Horizontal Alignment_ [Robert C. Martin's _Clean Code_].

### Закрывайте скобки в конце строки

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#закрывайте-скобки-в-конце-строки)

```ABAP
modify->update( node           = if_fra_alert_c=>node-item
                key            = item->key
                data           = item
                changed_fields = changed_fields ).
```

вместо излишне длинного

```ABAP
" anti-pattern
modify->update( node           = if_fra_alert_c=>node-item
                key            = item->key
                data           = item
                changed_fields = changed_fields
).
```

### При вызове с одним параметром указывайте его на той же строке

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#при-вызове-с-одним-параметром-указывайте-его-на-той-же-строке)

```ABAP
DATA(unique_list) = remove_duplicates( list ).
remove_duplicates( CHANGING list = list ).
```

вместо излишне длинного

```ABAP
" anti-pattern
DATA(unique_list) = remove_duplicates(
                           list ).
DATA(unique_list) = remove_duplicates(
                         CHANGING
                           list = list ).
```

### Указывайте параметры начиная со строки вызова

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#указывайте-параметры-начиная-со-строки-вызова)

```ABAP
DATA(sum) = add_two_numbers( value_1 = 5
                             value_2 = 6 ).
```

Если ваши строки становятся слишком длинными, вы можете перенести параметры на следующую строку:

```ABAP
DATA(sum) = add_two_numbers(
                value_1 = round_up( input DIV 7 ) * 42 + round_down( 19 * step_size )
                value_2 = VALUE #( ( `Calculation failed with a very weird result` ) ) ).
```

### При переносе строки сделайте отступ для параметров под вызовом

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#при-переносе-строки-сделайте-отступ-для-параметров-под-вызовом)

```ABAP
DATA(sum) = add_two_numbers(
                value_1 = 5
                value_2 = 6 ).
```

Если вы выровняете параметры в другом месте, будет трудно понять, к чему они относятся:

```ABAP
DATA(sum) = add_two_numbers(
    value_1 = 5
    value_2 = 6 ).
```

Тем не менее, это лучший шаблон, если вы хотите избежать нарушения форматирования при изменении длины названия метода.

### Сделайте разрыв строки для нескольких параметров

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#сделайте-разрыв-строки-для-нескольких-параметров)

```ABAP
DATA(sum) = add_two_numbers( value_1 = 5
                             value_2 = 6 ).
```

Да, это пустая трата места.
Но, если не делать перенос параметров на новую строку будет трудно определить, где заканчивается один параметр и начинается другой:

```ABAP
" anti-pattern
DATA(sum) = add_two_numbers( value_1 = 5 value_2 = 6 ).
```

### Выровняйте параметры

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#выровняйте параметры)

```ABAP
modify->update( node           = if_fra_alert_c=>node-item
                key            = item->key
                data           = item
                changed_fields = changed_fields ).
```

Из-за рваных краев трудно увидеть, где заканчивается параметр и начинается его значение:

```ABAP
" anti-pattern
modify->update( node = if_fra_alert_c=>node-item
                key = item->key
                data = item
                changed_fields = changed_fields ).
```

> С другой стороны, это лучший шаблон, если вы хотите избежать нарушения форматирования при изменении длины имени.

### Перенесите вызов на новую строку, если она станет слишком длинной

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#перенесите-вызов-на-новую-строку-если-она-станет-слишком-длинной)

```ABAP
DATA(some_super_long_param_name) =
  if_some_annoying_interface~add_two_numbers_in_a_long_name(
      value_1 = 5
      value_2 = 6 ).
```

### Добавьте отступы и табуляцию

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#добавьте-отступы-и-табуляцию)

Используйте 2 пробела для ключевых слов и 4 пробела для параметров:

```ABAP
DATA(sum) = add_two_numbers(
              EXPORTING
                value_1 = 5
                value_2 = 6
              CHANGING
                errors  = errors ).
```

Если у вас нет ключевых слов, сделайте для параметров отступ в 4 пробела.

```ABAP
DATA(sum) = add_two_numbers(
                value_1 = 5
                value_2 = 6 ).
```

Можно использовать Tab для отступа. Ничего страшного, если это добавит на один пробел больше, чем необходимо.
(Это происходит тогда, когда левая часть `DATA(sum) =` имеет нечетное количество символов.)

### Сделайте отступ для встроенных объявлений, таких как вызовы методов

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#сделайте-отступ-для-встроенных-объявлений-таких-как-вызовы-методов)

Делайте отступ для встроенных объявлений с помощью VALUE или NEW, как если бы они были вызовами методов:

```ABAP
DATA(result) = merge_structures( a = VALUE #( field_1 = 'X'
                                              field_2 = 'A' )
                                 b = NEW /clean/structure_type( field_3 = 'C'
                                                                field_4 = 'D' ) ).
```

### Не выравнивайте указания типов

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#не-выравнивайте-указания-типов)

```ABAP
DATA name TYPE seoclsname.
DATA reader TYPE REF TO /clean/reader.
```

Переменная и ее тип принадлежат друг другу и поэтому должны быть расположены близко друг к другу. 
Выравнивание ключевых слов `TYPE` отвлекает внимание от этой связи, предполагая, 
что переменные образуют одну вертикальную группу, а их типы — другую. 
Выравнивание также приводит к ненужному редактированию, поскольку изменение 
самого длинного имени переменной требует корректировки всех отступов.

```ABAP
" anti-pattern
DATA name   TYPE seoclsname.
DATA reader TYPE REF TO /clean/reader.
```

### Не объединяйте присвоения

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Форматирование](#форматирование) > [Эта секция](#не-объединяйте-присвоения)

```abap
var2 = var3.
var1 = var3.
```

```abap
var1 = xsdbool( var2 = var3 ).
```

Связанные в цепочку присвоения обычно сбивают с толку читателя. 
Кроме того, встроенное объявление не работает ни в одной позиции множественного присваивания.

```abap
" anti-pattern
var1 = var2 = var3.
```

## Тестирование

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Эта секция](#тестирование)

### Принципы

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Эта секция](#принципы)

#### Пишите тестируемый код

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Принципы](#принципы) > [Эта секция](#пишите-тестируемый-код)

Пишите весь код таким образом, чтобы вы могли протестировать его автоматически.

Если для этого требуется рефакторинг, проведите его.
Сделайте это перед тем, как начнете добавлять другие функции.

Если вы добавляете что-то новое в устаревший код, который слишком плохо структурирован для тестирования, 
реорганизуйте его хотябы так, чтобы вы могли протестировать свои дополнения.

#### Позвольте другим создавать моки

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Принципы](#принципы) > [Эта секция](#позвольте-другим-создавать-моки)

Если вы пишете код который будут использовать другие разработчики, напишите его так, чтобы можно было заменить его
тестовыми двойниками в модульных тестах. Этого можно достичь, например, добавляя интерфейсы в места, 
открытые наружу, создавая полезные тестовые двойники, которые позволяют проводить интеграционное 
тестирование, или применяя инверсию зависимостей, которая позволяет заменить продуктивную конфигурацию тестовой.

#### Правила удобочитаемости

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Принципы](#принципы) > [Эта секция](#правила-удобочитаемости)

Сделайте свой тестовый код еще более читабельным, чем ваш продуктивный код. 
Плохой продуктивный код с хорошими тестами легко исправить. 
Однако, если сами тесты плохие и неясные, вам будет не понятно, в каком направлении работать.

Сделайте свой тестовый код настолько простым, чтобы вы могли понять его даже спустя годы.

Придерживайтесь стандартов и шаблонов проектирования, чтобы ваши коллеги могли быстро разобраться в коде.

#### Не делайте копии и не пишите тестовые отчеты

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Принципы](#принципы) > [Эта секция](#не-делайте-копии-и-не-пишите-тестовые-отчеты)

Не начинайте работу над задачей из бэклога, создавая копию объекта разработки в `$TMP` и играя с ним. 
Другие люди не заметят эти объекты и, следовательно, не будут знать о состоянии вашей работы. 
Вы можете потратить впустую много времени, сначала создавая рабочую копию. 
Затем вы можете забыть удалить эту копию, загрязняя вашу систему и зависимости. 
(Не верите? Перейдите в свою систему разработки прямо сейчас и проверьте свой `$TMP`).

Также, не пишите тестовые отчеты, которые вам нужно будет повторно запускать вручную, 
и результаты которых вам нужно визуально проверять. 
Это настоящее испытание для несчастных людей: повторный запуск тестового отчета вручную и проверка на глаз, все ли в порядке.
Сделайте следующий шаг в этом направлении и автоматизируйте отчет с помощью модульного теста с автоматическим утверждением (assertion), 
которое сообщит вам, все ли в порядке с кодом. 
Во-первых, вы избавите себя от необходимости писать модульные тесты потом. 
Во-вторых, вы сэкономите много времени на ручных повторениях, а также не устанете от скуки.

#### Тестируйте публичные, а не приватные части

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Принципы](#принципы) > [Эта секция](#тестируйте-публичные-а-не-приватные-части)

Публичные части классов, особенно интерфейсы, которые они реализуют, достаточно стабильны и вряд ли изменятся. 
Сделайте так, чтобы ваши модульные тесты проверяли только публичные части, таким образом сделав их надежными 
и свести к минимуму усилия, которые вам придется приложить при рефакторинге класса. 
С другой стороны, защищенные и приватные внутренние элементы могут очень быстро меняться в результате рефакторинга, 
так что ваши тесты могут перестать работать после каждого рефакторинга.

Срочная необходимость протестировать приватные или защищенные методы 
может быть ранним сигналом о некоторых недостатках проектирования. 
Задайте себе вопрос:

- Вы случайно похоронили в своем классе концепцию, которая хочет выйти и стать отдельным классом со своим собственным набором тестов?

- Вы забыли отделить логику предметной области от связующего кода? 
Например, может быть не лучшей идеей реализация логики предметной области непосредственно в классе, подключенном к BOPF как действие, 
определение или проверка, или в классе, который был создан SAP Gateway как поставщик данных `*_DPC_EXT`.

- Ваши интерфейсы слишком сложны и требуют слишком много данных, которые не важны или которые нельзя легко замокать?

#### Не зацикливайтесь на покрытии кода

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Принципы](#принципы) > [Эта секция](#не-зацикливайтесь-на-покрытии-кода)

Покрытие нужно для того, чтобы помочь вам найти код, который вы забыли протестировать, а не для достижения какого-то случайного KPI:

Не придумывайте тесты с фиктивными утверждениями или без них только для того, чтобы достичь большего покрытия кода. 
Лучше оставлять вещи непроверенными, чтобы ясно показать, что вы не можете подвергнуть их рефакторингу без риска. 
Вы можете иметь менее 100% охвата и при этом иметь идеальные тесты. 
Есть случаи (например, IFы в конструкторе для вставки тестовых симуляций), которые на практике делают невозможным достижение 100%. 
Хорошие тесты, как правило, охватывают одну и ту же инструкцию несколько раз для разных ветвей и условий. 
Поэтому, теоретически покрытие кода у них превышает 100%.

### Тестовые классы

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Эта секция](#тестовые-классы)

#### Называйте локальные тестовые классы в соответствии с их назначением

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Тестовые классы](#тестовые-классы) > [Эта секция](#называйте-локальные-тестовые-классы-в-соответствии-с-их-назначением)

Назовите свой локальный тестовый класс как часть "когда" вашего тестового сценария.

```ABAP
CLASS ltc_<public method name> DEFINITION FOR TESTING ... ."
```

или назовите его "данная" ситуация.

```ABAP
CLASS ltc_<common setup semantics> DEFINITION FOR TESTING ... .
```

```ABAP
" anti-patterns
CLASS ltc_fra_online_detection_api DEFINITION FOR TESTING ... . " We know that's the class under test - why repeat it?
CLASS ltc_test DEFINITION FOR TESTING ....                      " Of course it's a test, what else should it be?
```

#### Поместите тесты в локальные классы

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Тестовые классы](#тестовые-классы) > [Эта секция](#поместите-тесты-в-локальные-классы)

Поместите модульные тесты в локальное тестовое включение тестируемого класса. 
Это позволит соавторам находить их при рефакторинге класса, 
а также запускать все связанные тесты одним нажатием клавиши, как описано в разделе 
[Как выполнять тестовые классы](#как-выполнять-тестовые-классы).

Поместите компонентные, интеграционные и системные тесты, в локальный тестовый инклуд отдельного глобального класса. 
Они не относятся напрямую к отдельному тестируемому классу, поэтому их следует помещать не в один из задействованных классов, а в отдельный класс. 
Отметьте этот глобальный тестовый класс как `FOR TESTING` и `ABSTRACT`, чтобы предотвратить случайную ссылку на него в реальном коде. 
Если тесты помещаются в другие классы, соавторы могут не заметить их и забыть запустить их при рефакторинге соответствующих классов.

Если возможно, используйте *test relations*, чтобы задокументировать, 
какие объекты охватываются тестом. 
В приведенном ниже примере, тестовый класс `hiring_test`
можно запустить в классе `recruting` или `candidate` с помощью сочетания клавиш `Shift-Crtl-F12` (Windows) или `Cmd-Shift-F12` (macOS).

```abap
"! @testing recruting
"! @testing candidate
class hiring_test definition
  for testing risk level dangerous duration medium
  abstract.
  ...
endclass.
```

#### Поместите вспомогательные методы во вспомогательные классы

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Тестовые классы](#тестовые-классы) > [Эта секция](#поместите-вспомогательные-методы-во-вспомогательные-классы)

Поместите вспомогательные методы, используемые несколькими тестовыми классами, во вспомогательный класс. 
Обеспечьте доступность вспомогательных методов посредством наследования (отношение «есть») или делегирования (отношение «имеет»).

```abap
" inheritance example

CLASS lth_unit_tests DEFINITION ABSTRACT.

  PROTECTED SECTION.
    CLASS-METHODS assert_activity_entity
      IMPORTING
        actual_activity_entity TYPE REF TO zcl_activity_entity
        expected_activity_entity TYPE REF TO zcl_activity_entity.
    ...
ENDCLASS.

CLASS lth_unit_tests IMPLEMENTATION.

  METHOD assert_activity_entity.
    ...
  ENDMETHOD.

ENDCLASS.

CLASS ltc_unit_tests DEFINITION INHERITING FROM lth_unit_tests FINAL FOR TESTING
  DURATION SHORT
  RISK LEVEL HARMLESS.
  ...
ENDCLASS.
```

#### Как выполнять тестовые классы

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Эта секция](#как-выполнять-тестовые-классы)

В ABAP Development Tools,  
нажмите Ctrl+Shift+F10 чтобы запустить все тесты класса.  
Нажмите Ctrl+Shift+F11 чтобы включить измерение покрытия.  
Нажмите Ctrl+Shift+F12 чтобы также запустить тесты в других классах, которые поддерживаются как тестовые отношения.

> На macOS, используйте `Cmd` вместо `Ctrl`.

### Тестируемый код

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Эта секция](#тестируемый-код)

#### Дайте осмысленное имя тестируемому коду или используйте имя по умолчанию CUT

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Тестируемый код](#тестируемый-код) > [Эта секция](#дайте-осмысленное-имя-тестируемому-коду-или-используйте-имя-по-умолчанию-cut)

Дайте переменной, которая представляет тестируемый код, осмысленное имя:

```ABAP
DATA blog_post TYPE REF TO ...
```

Не повторяйте просто имя класса со всеми его пространствами имен и префиксами:

```ABAP
" anti-pattern
DATA clean_fra_blog_post TYPE REF TO ...
```

Если у вас разные настройки тестирования, может быть полезно описать изменяющееся состояние объекта:

```ABAP
DATA empty_blog_post TYPE REF TO ...
DATA simple_blog_post TYPE REF TO ...
DATA very_long_blog_post TYPE REF TO ...
```

Если вы испытываете проблемы с поиском осмысленного имени, используйте `cut` по умолчанию. 
Аббревиатура расшифровывается как "тестируемый код" (code under test).

```ABAP
DATA cut TYPE REF TO ...
```

Это наиболее полезно в запутанных тестах, где вызов переменной `cut` может временно помочь читателю увидеть, 
что на самом деле тестируется. Но в долгосрочной перспективе лучше навести порядок в тестах.

#### Тестируйте интерфейсы, а не реализации

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Тестируемый код](#тестируемый-код) > [Эта секция](#тестируйте-интерфейсы-а-не-реализации)

Практическим следствием рекомендации [_Тестируйте публичные, а не приватные части_](#тестируйте-публичные-а-не-приватные-части),
является то, что вы должны указывать _интерфейс_ в типе для тестируемого кода,

```ABAP
DATA code_under_test TYPE REF TO some_interface.
```

а не _класс_

```ABAP
" anti-pattern
DATA code_under_test TYPE REF TO some_class.
```

#### Поместите вызов тестируемого кода в отдельный метод

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Тестируемый код](#тестируемый-код) > [Эта секция](#поместите-вызов-тестируемого-кода-в-отдельный-метод)

Если для тестируемого метода требуется много параметров и подготовленных данных, 
может помочь выделение вызова метода в отдельный вспомогательный метод, который заполняет значениями по умолчанию неинтересные нам параметры:

```ABAP
METHODS map_xml_to_itab
  IMPORTING
    xml_string TYPE string
    config     TYPE /clean/xml2itab_config DEFAULT default_config
    format     TYPE /clean/xml2itab_format DEFAULT default_format.

METHOD map_xml_to_itab.
  result = cut->map_xml_to_itab( xml_string = xml_string
                                 config     = config
                                 format     = format ).
ENDMETHOD.

DATA(itab) = map_xml_to_itab( '<xml></xml>' ).
```

Вызывая исходный метод напрямую, вы рискуете "утопить" свой тест в массе незначительных деталей:

```ABAP
" anti-pattern
DATA(itab) = cut->map_xml_to_itab( xml_string = '<xml></xml>'
                                   config     = VALUE #( 'some meaningless stuff' )
                                   format     = VALUE #( 'more meaningless stuff' ) ).
```

### Инъекция

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Эта секция](#инъекция)

#### Используйте инверсию зависимостей для внедрения тестовых двойников

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Инъекция](#инъекция) > [Эта секция](#используйте-инверсию-зависимостей-для-внедрения-тестовых-двойников)

Инверсия зависимостей означает, что вы передаете все зависимости конструктору:

```ABAP
METHODS constructor
  IMPORTING
    customizing_reader TYPE REF TO if_fra_cust_obj_model_reader.

METHOD constructor.
  me->customizing_reader = customizing_reader.
ENDMETHOD.
```

Не используйте сеттер для инъекции. 
Это позволяет использовать продуктивный код способами, для которых он не предназначен:

```ABAP
" anti-pattern
METHODS set_customizing_reader
  IMPORTING
    customizing_reader TYPE REF TO if_fra_cust_obj_model_reader.

METHOD do_something.
  object->set_customizing_reader( a ).
  object->set_customizing_reader( b ). " would you expect that somebody does this?
ENDMETHOD.
```
Не используйте FRIENDS инъекции.
Это инициализирует продуктивные зависимости до того, как они будут заменены, что может привести к неожиданным последствиям. 
Это сломается, как только вы переименуете внутренние части. 
Также это обходит инициализацию в конструкторе.

```ABAP
" anti-pattern
METHOD setup.
  cut = NEW fra_my_class( ). " <- builds a productive customizing_reader first - what will it break with that?
  cut->customizing_reader ?= cl_abap_testdouble=>create( 'if_fra_cust_obj_model_reader' ).
ENDMETHOD.

METHOD constructor.
  customizing_reader = fra_cust_obj_model_reader=>s_get_instance( ).
  customizing_reader->fill_buffer( ). " <- won't be called on your test double, so no chance to test this
ENDMETHOD.
```

#### Рассмотрите возможность использования инструмента ABAP test double

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Инъекция](#инъекция) > [Эта секция](#рассмотрите-возможность-использования-инструмента-abap-test-double)

```ABAP
DATA(customizing_reader) = CAST /clean/customizing_reader( cl_abap_testdouble=>create( '/clean/default_custom_reader' ) ).
cl_abap_testdouble=>configure_call( customizing_reader )->returning( sub_claim_customizing ).
customizing_reader->read( 'SOME_ID' ).
```

Это короче и проще для понимания, чем пользовательские тестовые двойники:

```ABAP
" anti-pattern
CLASS /dirty/default_custom_reader DEFINITION FOR TESTING CREATE PUBLIC.
  PUBLIC SECTION.
    INTERFACES /dirty/customizing_reader.
    DATA customizing TYPE /dirty/customizing_table.
ENDCLASS.

CLASS /dirty/default_custom_reader IMPLEMENTATION.
  METHOD /dirty/customizing_reader~read.
    result = customizing.
  ENDMETHOD.
ENDCLASS.

METHOD test_something.
  DATA(customizing_reader) = NEW /dirty/customizing_reader( ).
  customizing_reader->customizing = sub_claim_customizing.
ENDMETHOD.
```

#### Используйте инструменты тестирования

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Инъекция](#инъекция) > [Эта секция](#используйте-инструменты-тестирования)

В целом, чистый стиль программирования 
позволит вам выполнять большую часть работы 
со стандартными модульными тестами ABAP и тестовыми двойниками.
Однако есть инструменты, которые позволят вам 
элегантно решать более сложные задачи:

- Используйте службу `CL_OSQL_REPLACE` для тестирования сложных операторов OpenSQL, 
перенаправляя их в корзину тестовых данных, которую можно заполнить тестовыми данными, не мешая остальной системе.

- Используйте CDS test framework для тестирования ваших CDS представлений.

#### Используйте тестовые швы как временное решение

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Инъекция](#инъекция) > [Эта секция](#используйте-тестовые-швы-как-временное-решение)

Если все другие методы не работают или вы работаете с устаревшим кодом, 
воздержитесь от [тестовых швов](https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-US/index.htm?file=abaptest-seam.htm), 
чтобы сделать код пригодным для тестирования.

Хотя на первый взгляд они могут показаться удобным решением, тестовые швы являются инвазивными и, как правило, 
увязают в частных зависимостях, что затрудняет поддержание их в рабочем состоянии и стабильность в долгосрочной перспективе.

Поэтому мы рекомендуем воздержаться от тестовых швов и использовать их только в качестве временного обходного пути, 
чтобы вы могли придать коду более тестируемую форму.

#### Используйте LOCAL FRIENDS для доступа к конструктору инверсии зависимостей

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Инъекция](#инъекция) > [Эта секция](#используйте-local-friends-для-доступа-к-конструктору-инверсии-зависимостей)

```ABAP
CLASS /clean/unit_tests DEFINITION.
  PRIVATE SECTION.
    DATA cut TYPE REF TO /clean/interface_under_test.
    METHODS setup.
ENDCLASS.

CLASS /clean/class_under_test DEFINITION LOCAL FRIENDS unit_tests.

CLASS unit_tests IMPLEMENTATION.
  METHOD setup.
    DATA(mock) = cl_abap_testdouble=>create( '/clean/some_mock' ).
    " /clean/class_under_test is CREATE PRIVATE
     " so this only works because of the LOCAL FRIENDS
    cut = NEW /clean/class_under_test( mock ).
  ENDMETHOD.
ENDCLASS.
```

#### Не злоупотребляйте LOCAL FRIENDS для вторжения в проверенный код

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Инъекция](#инъекция) > [Эта секция](#не-злоупотребляйте-local-friends-для-вторжения-в-проверенный-код)

Модульные тесты, которые обращаются к приватным и защищенным членам класса для вставки мок данных, являются хрупкими: 
они перестают работать при изменении внутренней структуры тестируемого кода.

```ABAP
" anti-pattern
CLASS /dirty/class_under_test DEFINITION LOCAL FRIENDS unit_tests.
CLASS unit_tests IMPLEMENTATION.
  METHOD returns_right_result.
    cut->some_private_member = 'AUNIT_DUMMY'.
  ENDMETHOD.
ENDCLASS.
```

#### Не изменяйте продуктивный код, чтобы сделать код пригодным для тестирования

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Инъекция](#инъекция) > [Эта секция](#не-изменяйте-продуктивный-код-чтобы-сделать-код-пригодным-для-тестирования)

```ABAP
" anti-pattern
IF me->in_test_mode = abap_true.
```

#### Не создавайте подклассы чтобы замокать методы

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Инъекция](#инъекция) > [Эта секция](#не-создавайте-подклассы-чтобы-замокать-методы)

Не создавайте подклассы и не переопределяйте методы, чтобы моделировать их в модульных тестах. 
Это решение хоть и работает, но оно хрупкое, потому что тесты часто перестают работать после рефакторинга кода. 
Кроме того, оно позволяет реальным потребителям наследоваться от вашего класса, 
что [может привести к неприятным сюрпризам, если вы явно не спроектируете его для наследования](#final-если-не-предназначен-для-наследования).

```ABAP
" anti-pattern
CLASS unit_tests DEFINITION INHERITING FROM /dirty/real_class FOR TESTING [...].
  PROTECTED SECTION.
    METHODS needs_to_be_mocked REDEFINITION.
```

Чтобы тестировать устаревший код, все же лучше [использовать тестовые швы](#используйте-тестовые-швы-как-временное-решение). 
Они такие же хрупкие, но все же самые чистые решения, поскольку они не изменяют продуктивное поведение класса, 
в отличие от включения наследования путем удаления флага `FINAL` или изменения области действия метода с `PRIVATE` на `PROTECTED`.

При написании нового кода учитывайте эту проблему тестируемости непосредственно при разработке класса 
и найдите другой, лучший способ. 
Общепринятые лучшие практики включают [использование инструментов тестирования](#используйте-инструменты-тестирования)
и выделение проблемного метода в отдельный класс с собственным интерфейсом.

> Более конкретный вариант
> [Не изменяйте продуктивный код, чтобы сделать код пригодным для тестирования](#не-изменяйте-продуктивный-код-чтобы-сделать-код-пригодным-для-тестирования).

#### Не мокайте то, что вам не нужно

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Инъекция](#инъекция) > [Эта секция](#не-мокайте-то-что-вам-не-нужно)

```ABAP
cut = NEW /clean/class_under_test( db_reader = db_reader
                                   config    = VALUE #( )
                                   writer    = VALUE #( ) ).
```

Определите свои данные как можно точнее: не устанавливайте данные, которые не нужны вашему тесту, 
и не мокайте объекты, которые никогда не вызываются. 
Эти вещи отвлекают читателя от того, что происходит на самом деле.

```ABAP
" anti-pattern
cut = NEW /dirty/class_under_test( db_reader = db_reader
                                   config    = config
                                   writer    = writer ).
```

Также бывают случаи, когда вообще не нужно что-то мокать — обычно это касается структур и контейнеров данных. 
Например, ваши модульные тесты могут хорошо работать с продуктивной версией `transient_log`, 
потому что он всего лишь сохраняет данные без каких-либо побочных эффектов.

#### Не создавайте тестовые фреймворки

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Инъекция](#инъекция) > [Эта секция](#не-создавайте-тестовые-фреймворки)

Модульные тесты — в отличие от интеграционных тестов — должны быть data-in-data-out, 
при этом все тестовые данные должны определяться на лету по мере необходимости.

```ABAP
cl_abap_testdouble=>configure_call( test_double )->returning( data ).
```

Не начинайте создавать фреймворки, которые решают, какие данные предоставить, на основе "*идентификаторов тестовых случаев*". 
Полученный код будет настолько длинным и сложным, что эти тесты будут не жизнеспособны в долгосрочной перспективе.

```ABAP
" anti-pattern

test_double->set_test_case( 1 ).

CASE me->test_case.
  WHEN 1.
  WHEN 2.
ENDCASE.
```

### Тестовые методы

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Эта секция](#тестовые-методы)

#### Названия тестовых методов должны отражать то, что дано и что ожидается

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Тестовые методы](#тестовые-методы) > [Эта секция](#названия-тестовых-методов-должны-отражать-то-что-дано-и-что-ожидается)

Хорошие имена отражают что "дано" и что будет "тогда" (желаемая целевая ситуация теста) .

```ABAP
METHOD reads_existing_entry.
METHOD throws_on_invalid_key.
METHOD detects_invalid_input.
```

Плохие имена отражают "когда", повторяют бессмысленные факты или носят загадочный характер:

```ABAP
" anti-patterns

" What's expected, success or failure?
METHOD get_conversion_exits.

" It's a test method, what else should it do but "test"?
METHOD test_loop.

" So it's parameterized, but what is its aim?
METHOD parameterized_test.

" What's "_wo_w" supposed to mean and will you still remember that in a year from now?
METHOD get_attributes_wo_w.
```

Поскольку ABAP допускает использование только 30 символов в именах методов, 
можно добавить поясняющий комментарий, если имя слишком короткое, чтобы передать достаточное значение. 
ABAP Doc или первая строка тестового метода могут хорошо подходить для комментария.

Если у вас есть большое количество тестовых методов со слишком длинными именами, 
это может указывать на то, что вам лучше разделить один тестовый класс на несколько 
и выразить различия в начальных условиях "дано" в соответствующих именах классов.

#### Используйте формат дано-когда-тогда

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Тестовые методы](#тестовые-методы) > [Эта секция](#используйте-формат-дано-когда-тогда)

Организуйте свой тестовый код в соответствии с парадигмой "данные-когда-тогда": 
во-первых, инициализируйте все начальные условия в разделе "дано". 
Затем вызовите тестируемый код ("когда"). 
Наконец, подтвердите ожидаемый результат ("тогда").

Если разделы "дано" или "тогда" становятся настолько длинными, 
что вы больше не можете визуально выделить три секции, лучше всего извлечь подметоды. 
Пустые строки или комментарии в качестве разделителей на первый взгляд могут быть хорошим решением, 
но на самом деле они не уменьшают визуальный беспорядок. 
Тем не менее, они помогают читателю и начинающему автору тестов разделять разделы.

#### "Когда" ровно один вызов

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Тестовые методы](#тестовые-методы) > [Эта секция](#когда-ровно-один-вызов)

Убедитесь, что раздел "когда" вашего тестового метода содержит только вызов тестируемого класса:

```ABAP
METHOD rejects_invalid_input.
  " when
  DATA(is_valid) = cut->is_valid_input( 'SOME_RANDOM_ENTRY' ).
  " then
  cl_abap_unit_assert=>assert_false( is_valid ).
ENDMETHOD.
```

Вызов нескольких вещей указывает на то, что у метода нет четкой направленности и он проверяет слишком много вещей. 
Это усложняет поиск причины падения теста: первый, второй или третий вызов, вызвал падение? 
Это также сбивает с толку читателя, потому что он не уверен, что именно тестируется.

#### Не добавляйте TEARDOWN если вам это не нужно

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Тестовые методы](#тестовые-методы) > [Эта секция](#не-добавляйте-teardown-если-вам-это-не-нужно)

`teardown` методы обычно нужны только для очистки записей базы данных или других внешних ресурсов в интеграционных тестах. 

Сброс атрибутов тестового класса, особенно `cut`, или атрибутов тестовых двойников избыточен;
они будут перезаписаны методом настройки перед `setup` следующего метода тестирования.

### Тестовые данные

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Эта секция](#тестовые-данные)

#### Упростите определение смысла

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Тестовые данные](#тестовые-данные) > [Эта секция](#упростите-определение-смысла)

В модульных тестах вы хотите иметь возможность быстро определить, какие вещи важны,
а какие нужны только для того, чтобы предотвратить сбой. 
Поэтому, давайте вещам, которые не имеют значения, очевидные имена и значения, например:

```ABAP
DATA(alert_id) = '42'.                             " well-known meaningless numbers
DATA(detection_object_type) = '?=/"&'.             " 'keyboard accidents'
CONSTANTS some_random_number TYPE i VALUE 782346.  " revealing variable names
```

Не обманывайте людей, заставляя их поверить, что что-то может быть связано с реальными объектами или реальными настройками, если это не так:

```ABAP
" anti-pattern
DATA(alert_id) = '00000001223678871'.        " this alert really exists
DATA(detection_object_type) = 'FRA_SCLAIM'.  " this detection object type, too
CONSTANTS memory_limit TYPE i VALUE 4096.    " this number looks carefully chosen
```

#### Упростите поиск различий

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Тестовые данные](#тестовые-данные) > [Эта секция](#упростите-поиск-различий)

```ABAP
exp_parameter_in = VALUE #( ( parameter_name = '45678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789END1' )
                            ( parameter_name = '45678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789END2' ) ).
```

Не заставляйте читателей сравнивать длинные бессмысленные строки, чтобы обнаружить крошечные различия.

#### Используйте константы для описания предназначения тестовых данных

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Тестовые данные](#тестовые-данные) > [Эта секция](#используйте-константы-для-описания-предназначения-тестовых-данных)

```ABAP
CONSTANTS some_nonsense_key TYPE char8 VALUE 'ABCDEFGH'.

METHOD throws_on_invalid_entry.
  TRY.
      " when
      cut->read_entry( some_nonsense_key ).
      cl_abap_unit_assert=>fail( ).
    CATCH /clean/customizing_reader_error.
      " then
  ENDTRY.
ENDMETHOD.
```

### Утверждения

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Эта секция](#утверждения)

#### Несколько целенаправленных утверждений

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Утверждения](#утверждения) > [Эта секция](#несколько-целенаправленных-утверждений)

Используйте утверждения (аssert) только для того, на что ссылается метод тестирования, и ограничьте их количество.

```ABAP
METHOD rejects_invalid_input.
  " when
  DATA(is_valid) = cut->is_valid_input( 'SOME_RANDOM_ENTRY' ).
  " then
  cl_abap_unit_assert=>assert_false( is_valid ).
ENDMETHOD.
```

Слишком много утверждений указывает на то, что метод не имеет четкой цели. 
Это связывает производственный и тестовый код во многих местах: 
при изменении функции приходится переписывать большое количество тестов, 
даже если они на самом деле не имеют ничего общего с измененной функцией. 
Слишком много утверждений также сбивает с толку читателя, 
потому что трудно определить одно утверждение, которое действительно важно.

```ABAP
" anti-pattern
METHOD rejects_invalid_input.
  " when
  DATA(is_valid) = cut->is_valid_input( 'SOME_RANDOM_ENTRY' ).
  " then
  cl_abap_unit_assert=>assert_false( is_valid ).
  cl_abap_unit_assert=>assert_not_initial( log->get_messages( ) ).
  cl_abap_unit_assert=>assert_equals( act = sy-langu
                                      exp = 'E' ).
ENDMETHOD.
```

#### Используйте правильный тип утверждения

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Утверждения](#утверждения) > [Эта секция](#используйте-правильный-тип-утверждения)

```ABAP
cl_abap_unit_assert=>assert_equals( act = table
                                    exp = test_data ).
```

Утверждения часто делают больше, чем кажется на первый взгляд. Например, `assert_equals` также проверяет, 
совместимы ли два типа данных, и предоставляет точные описания, если значения различаются. 
Использование ложных, слишком общих утверждений заставляет вас зайти в отладчик, 
а не позволяет понять в чем причина ошибки непосредственно из сообщения.

```ABAP
" anti-pattern
cl_abap_unit_assert=>assert_true( xsdbool( act = exp ) ).
```

#### Утверждайте содержание, а не количество

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Утверждения](#утверждения) > [Эта секция](#утверждайте-содержание-а-не-количество)

```ABAP
assert_contains_exactly( actual   = table
                         expected = VALUE string_table( ( `ABC` ) ( `DEF` ) ( `GHI` ) ) ).
```

Не пишите утверждения с набором магических чисел, лучше укажите фактические данные, которые вы ожидаете получить. 
Числа могут быть разными, но данные все еще можут быть ожидаемыми. 
И наоборот, числа могут быть одинаковыми, а данные совершенно неожиданными.

```ABAP
" anti-pattern
assert_equals( act = lines( log_messages )
               exp = 3 ).
```

#### Утверждайте качество, а не содержание

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Утверждения](#утверждения) > [Эта секция](#утверждайте-качество-а-не-содержание)

Если вас интересует только мета качество результата, а не само содержимое, выразите это с помощью подходящего утверждения:

```ABAP
assert_all_lines_shorter_than( actual_lines        = table
                               expected_max_length = 80 ).
```

Проверка точного содержимого скрывает то, что вы действительно хотите протестировать. 
Такое решение также является хрупким, потому что рефакторинг может дать другой, но вполне приемлемый результат, 
хотя и сломает все ваши слишком точные модульные тесты.

```ABAP
" anti-pattern
assert_equals( act = table
               exp = VALUE string_table( ( `ABC` ) ( `DEF` ) ( `GHI` ) ) ).
```

#### Используйте FAIL для проверки ожидаемых исключений

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Утверждения](#утверждения) > [Эта секция](#используйте-fail-для-проверки-ожидаемых-исключений)

```ABAP
METHOD throws_on_empty_input.
  TRY.
      " when
      cut->do_something( '' ).
      cl_abap_unit_assert=>fail( ).
    CATCH /clean/some_exception.
      " then
  ENDTRY.
ENDMETHOD.
```

#### Не перехватывайте неожиданные исключения, а перенаправляйте их

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Утверждения](#утверждения) > [Эта секция](#не-перехватывайте-неожиданные-исключения-а-перенаправляйте-их)

```ABAP
METHODS reads_entry FOR TESTING RAISING /clean/some_exception.

METHOD reads_entry.
  "when
  DATA(entry) = cut->read_something( ).
  "then
  cl_abap_unit_assert=>assert_not_initial( entry ).
ENDMETHOD.
```

Ваш тестовый код по-прежнему ориентирован на благополучный исход, поэтому его намного легче читать и понимать по сравнению с:

```ABAP
" anti-pattern
METHOD reads_entry.
  TRY.
      DATA(entry) = cut->read_something( ).
    CATCH /clean/some_exception INTO DATA(unexpected_exception).
      cl_abap_unit_assert=>fail( unexpected_exception->get_text( ) ).
  ENDTRY.
  cl_abap_unit_assert=>assert_not_initial( entry ).
ENDMETHOD.
```

#### Напишите собственные утверждения чтобы сократить код и избежать дублирования

> [Чистый ABAP](#чистый-abap) > [Содержание](#содержание) > [Тестирование](#тестирование) > [Утверждения](#утверждения) > [Эта секция](#напишите-собственные-утверждения-чтобы-сократить-код-и-избежать-дублирования)

```ABAP
METHODS assert_contains
  IMPORTING
    actual_entries TYPE STANDARD TABLE OF entries_tab
    expected_key   TYPE key_structure.

METHOD assert_contains.
  TRY.
      actual_entries[ key = expected_key ].
    CATCH cx_sy_itab_line_not_found.
      cl_abap_unit_assert=>fail( |Couldn't find the key { expected_key }| ).
  ENDTRY.
ENDMETHOD.
```

Вместо того, чтобы копировать это и вставлять снова и снова.
